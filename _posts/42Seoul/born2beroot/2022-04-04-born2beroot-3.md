---
title: "Born2beroot(3)"
excerpt: "This document is a System Administration related exercise"

categories:
  - born2beroot
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-04-04
last_modified_at: 2022-04-04
---

<br>
<br>

# 리눅스의 패키지 관리

대부분의 리눅스 배포판은 몇 천개의 패키지를 가진 온라인 레포지토리와 연결된 패키지 관리툴을 사용한다.  
운영체제의 컴포넌트, 문서, 응용프로그램을 쉽게 삭제할 수 있고, 설치할 수 있다.

데비안은 패키지 포맷으로 `.deb` 를 가지며,  
패키지 관리자로 `dpkg, apt-get, aptitude`가 있고, 이는 대부분의 배포판(데비안 뿐만 아니라, 우분투, 민트 등)과 비슷하다.

CentOS의 경우, Red Hat 패키지 포맷으로 `.rpm`을 가지는데, `rpm, yum`이 패키지 관리자이다. 그리고 이는 Red Hat, Fedora CentOS 와 비슷하다.

<br>

## 패키지 용어

패키지로 사용가능한 리눅스 배포판의 많은 소프트웨어와 문서들은 `repository`라는 곳을 통해 배포된다.

`.deb`패키지들은 데비안, 우분투, 민트 등과 같은 데비안과 우분투의 파생모델에서 사용되는데, `apt-get(apt와 내부 동작 차이가 없음), aptitude`를 사용할 수 있다.

<br>

### apt, aptitude

aptitude와 apt-get은 dpkg의 프론트 엔드이고,  
다른 그래픽 유저 인터페이스의 백엔드이고,  
다른 그래픽 유저 인터페이스의 백엔드이다.

`apt`는 `Advanced Packaging Tool`의 약자로 오픈소스이다.  
`.deb`패키지의 일부였으나, 현재는 `.rpm`패키지와 함께 작동할 수 있다.

<br>

`aptitude`는 고급 패키징 도구이고, apt보다 상위 수준의 패키지 관리자이다.  
`aptitude`는 apt-get, apt-mark, apt-cache의 기능을 포함해 더 많은 기능을 제공한다.

또한 `aptitude`는 대화형 UI가 제공된다는 장점이 있다. 반면, `apt`는 저수준 패키지 관리자로써, 커맨드라인 인터페이스로 제한되어있다.

위처럼 `aptitude`가 `apt`보다 더 많은 기능을 가지고 있음을 알 수 있다.

<br><br>

# SELinux, Apparmor

## SeLinux

`Security-Enhanced Linux`의 줄임말이다.  
레드햇 계열(위의 CentOS, Fedora, Red Hat 등)에서 사용된다.  
시스템 전체에 보안을 설정할 수 있다.

표준 유닉스 권한은 는 `Discretionary Access Control, DAC`으로 파일에 권한을 주게된다.  
어떤 유저가 어느 파일을 소유하고 있다면 해당파일을 `chmod 777`로 유저 전체가 읽을 수 있게 할 수 있다는 것이다.

`selinux`를 사용하면, 커널은 `Mandatory Access Control, MAC`을 강제하는데, 이는 DAC의 대용품으로써 프로세스들 또는 쓰레드들이 그 파일로 무엇을 할 수 있는지 컨트롤할 수 있다.  
커널에 의해서 프로세스들이 필요로하는 최소한의 접근만 가능할 수 있게 막을 수 있다.

<br>

## App armor

데비안의 리눅스 커널에는 SELinux 가 기본적으로 비활성화 되어있다.  
대신, 데비안계열(데비안, 우분투, 민트 등)에서 사용되는 `AppArmor`가 있다.  
표준 유닉스에서 위와같이 DAC모델로 보안하는데, 이를 보완한 리눅스 커널 보안 모듈이다.

<br>

위의 SELinux와는 달리, 개별 응용프로그램을 보호하고, 응용프로그램 단위의 보안모델을 가진다.  
이에 따라, SELinux보다 덜 복잡하고, 더 적은 수의 작업을 제어할 수 있다.

<br>

- 기능
  AppArmor는 특정 프로그램, 컨테이너에서 필요한 리눅스 기능, 네트워크 사용, 파일 권한 등에 대한 접근을 허용하는 프로파일로 구성되고, 각 프로파일은 enforce 또는 complain 모드로 실행할 수 있다.

데비안에서 apparmor는 시스템이 부팅될때, 자동으로 실행된다.  
현재 AppArmor가 작동하는지 확인하기 위해선, `/usr/sbin/aa-status`로 확인할 수 있다.

<br>
<br>

# SSH

## 개요

secure shell, ssh는 원격 리눅스 컴퓨터와 상호작용을 하기 위한 보안 프로토콜을 사용하는 도구들을 의미한다.

예전에는 telnet, rlogin, rsh 등으로 원격 컴퓨터를 서버에 연결했는데, 이 프로토콜들은 로그인세션을 암호화하지 않아 사용자의 아이디 비밀번호가 `wireshark, tcpdump`에 의해 가로채기 당했다.  
위의 것들은 더이상 사용되지 않고, ssh가 사용된다.

ssh 프로토콜은 2가지의 방법으로 보호되는데,

1. 접속이 암호화된다.
2. 접속이 양방향으로 인증된다.

<br>

## 사용

- 리눅스를 데스크탑대용으로 사용하는 경우는 거의 없다.
- 리눅스는 서버 시장에서 압도적 다수를 차지하기 때문에 사용된다.
- IOT처럼 사물인터넷에서 사물의 안에 설치된 작은 컴퓨터는 리눅스이다.

<br>

client의 컴퓨터로 server의 컴퓨터를 원격제어 해야할때 사용되는게 SSH.
리눅스 계열의 서버컴퓨터를 원격제어해야할때 사용되는게 SSH.
SSH를 사용하기위해선 서버컴퓨터에 SSH Server를 깔아야하고,
제어하는 컴퓨터에는 SSH Client가 깔려있어야한다.
SSH Client에서 원격명령을 내리면, SSH Server가 자신이 설치된 Server컴퓨터에 직접적으로 명령을 내리는 구조이다.

ssh 접속은 터널이 입력되기 전에 암호화되고, 그리고 사용자의 아이디/비밀번호 또는 public/private key를 이용한 인증이 이루어진다.

<br>

## public, private keys

ssh 프로토콜은 `public key 와private key`로 이뤄진다.  
A라는 컴퓨터와 B라는 컴퓨터가 있다고 생각해보자.  
A컴퓨터가 B컴퓨터에게 암호화된 메세지를 보내고 싶다면,

- A에는 B의 public key가 있어야한다.
- B는 A와 public key를 공유해야한다.
- 단, B의 private key는 자신만 알고 있어야한다.

이 상황에서, B컴퓨터는 A의 암호화된 메세지를 읽을 수 있는 유일한 컴퓨터가 된다.

<br>

B가 메세지가 A로부터 온 것인지 확인하기 위해서, B는 A의 public key를 확인해 A가 private key로 메세지에 서명했는지 확인한다.  
A가 A만의 private key를 가지고 있으므로, B는 A가 보낸 메세지임을 확인할 수 있게된다.

위에서 메세지를 보내고 싶어하는 A가 Client, B가 Server라고 생각하면된다.

<br>

## 설치

- 맥에는 기본적으로 ssh 깔려있음.
- ssh-keygen 프로그램을 이용해 client에서 키를 만들 수 있다.
- ssh key는 서버에 접속할때 비밀번호를 요구하는 것보다 높은 보안수준을 요구할때 사용되는 보안방식.
- ssh [로그인할 아이디]@[서버 아이피] 로 접속.

그래서 client의 private key와 server의 public key가 서로 일치하는 것이 확인되면, 로그인 인증에 성공한다.

<br><br>

# sudo

# IP주소

컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기위해서 사용하는 특수한 번호.  
`~.~.~.~`처럼 .이 3개인 숫자의 연속이다.  
정확하게는, 32bit(4byte)짜리 숫자의 모음이라고 생각하면된다.

<img src="https://user-images.githubusercontent.com/76278794/161493678-cf2f6961-ac67-45ad-a7e5-471d79224485.png">

#
