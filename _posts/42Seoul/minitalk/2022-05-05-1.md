---
title: "minitalk(1)"
excerpt: "Small data exchange program using UNIX signals"

categories:
  - minitalk
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-05-05
last_modified_at: 2022-05-05
---

<br><br>

## Process

### 용어

- process
  시스템 상에서 현재 구동되고 있는 컴파일된 소스코드를 의미한다.  
  예를들어, C, C++로 프로그램을 작성해 컴파일하면 컴퓨터가 이해할 수 있는 바이너리 코드를 생성하는데, C, C++로 작성된 코드와 바이너리 코드는 모두 프로그램이다.  
  그리고, 이 바이너리 코드를 실행하면 프로세스가 된다.
  <br>
  프로그램은 수동 엔터티로 간주되지만, 프로세스는 능동 엔터티로 간주된다.  
  하나의 프로그램은 여러 번 실행됨에따라 많은 프로세스를 생성할 수 있다.(fdf를 여러개 실행할 수 있듯...)

  프로세스가 실행되면, 메모리에 프로세스가 올라가게되는데, 코드는 text영역, 전역변수는 data영역, 지역변수와 매개변수 등은 stack, 동적할당된 메모리는 heap으로 나뉘게된다.

- process 상태
  process의 상태는 7개 중 1개에 해당된다.
  1. new : 새로 생성된, 생성 중인 프로세스.
  2. ready : 생성된 프로세스가 준비상태로 이동함. 실행할 준비가 완료됨
  3. run : CPU에서 작동중인 프로세스.
  4. wait(or block) : 프로세스가 I/O access를 요청함
  5. Complete(or Terminated) : 프로세스가 실행을 완료함
  6. Suspended Ready : ready queue가 꽉찼을 때, 몇몇 프로세스는 suspended ready state로 이동함.
  7. Suspended Block : waiting queue가 꽉찼을 때, 상동.

- PID
  모든 프로세스는 process id, PID를 가지고 있다.

- PPID
  각각의 프로세스는 부모 프로세스(PPID)를 가지고 있으며, 자식 프로세스는 종종 부모 프로세스에 의해 시작된다.

- init
  init 프로세스는 항당 ID 1번을 가지고 있다.  
  init 프로세스는 kernel에 의해 시작되며, 이에따라 부모프로세스가 기술적으로 존재하지 않게된다.(모든 프로세스가 부모 프로세스를 가지고 있음에도 불구하고)  
  init은 고립된 프로세스들(orphaned processes)의 양부모 역할을 한다.

- kill
  process가 멈추거나, 죽거나, 죽고싶을 때, kill로 프로세스를 없앨 수 있다.

- daemon
  시스템이 시작될 때, 같이 시작되면서 영원히 구동되는 프로세스들을 daemon process라고 부른다. 
  이 daemon process들은 절대로 죽지 않는다.

- zombie
  프로세스가 죽었는데, 시스템상에서 아직 보인다면, zombie프로세스라고 불린다.  
  zombie프로세스들은 이미 죽은 상태이므로 kill할 수 없다.

<br>

### 기본적인 프로세스 관리

- $$, PPID
  몇몇 쉘 환경변수는 프로세스에 대한 정보를 가지고 있다.  
  $$변수는 현재 PID에 대한 정보를 가지고 있고,  
  $PPID 변수는 부모의 PID를 가지고 있다.  
  정확하게는, $$은 쉘의 변수가 아닌 쉘 인자이기 때문에 값을 할당할 수 없다.

  ```sh
  echo $$ $PPID
  ```

- pidof
  pidof 명령어를 통해 이름으로 모든 프로세스의 아이디들을 찾을 수 있다.

  ```sh
  pidof mingetty
  ```

- parent, child 부모와 자식

  프로세스들은 부모-자식 관계를 가지고 있다.
  그리고 모든 프로세스들은 부모 프로세스를 가지고 있다.(init제외)
  예시가 있는데,  

  ```sh
  echo $$ $PPID
  zsh
  echo $$ $PPID
  exit
  echo $$ $PPID
  ```

  위 명령어의 결과를 보게되면,  
  
  ```
  myukang@c4r8s1 ~ % echo $$ $PPID 
  81206 81044
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  81260 81206
  myukang@c4r8s1 ~ % exit
  myukang@c4r8s1 ~ % echo $$ $PPID
  81206 81044
  ```

  현재 쉘의 PID는 81206인데, zsh로 새로운 쉘을 만들어내니까  
  PID 81206을 부모로하는 자식 프로세스 81260을 만들어낸다.  
  그리고 exit로 만들었던 쉘을 종료하니, 다시 자기자신으로 돌아온 것을 볼 수 있다.  

- fork , exec
  프로세스는 다른 프로세스를 만들 때, 2가지 과정을 거친다.  
  첫 번째로, 프로세스는 동일한 사보인 자기 자신의 `fork`를 만들어낸다.  
  그리고 그 fork된 사본 프로세스는 `exec`을 실행해 fork된 프로세스를 target child process와 바꾼다.

- exec
  exec 명령어로, 새로운 프로세스를 fork할 필요 없이 프로세스를 실행할 수 있다.  
  
  ```sh
  myukang@c4r8s1 ~ % echo $$
  81206
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec bash
  bash-3.2$ echo $$ $PPID
  82241 81206
  bash-3.2$ exit
  exit
  myukang@c4r8s1 ~ % echo $$ 
  81206
  myukang@c4r8s1 ~ % 
  ```

## interrupts

interrupt를 이해하기 위해 bus를 먼저 보자.  

하드웨어 구성요소는 CPU와 통신할 때, bus를 이용하게된다.  
오늘날 흔히 사용되는 bus는 usb, pci, agp, pci-express 와 같은 `plug and play bus`들이다.  

`interrupt request, IRQ`는 장치가 CPU에게 보내는 요청이다.  
장치가 CPU가 읽어야하는 데이터를 가지고 있을 때, CPU에게 집중을 요구하기 위해 `interrupt`를 발생시킨다.  

`irq`는 장치들간에 공유될 수 있다.  
Interrupt 0번은 timer를 위해 예약되어있으며, 1은 키보드를 위해 예약되어있다.  
2번은 IRQ 8 ~ 15번까지의 통로이다.  



<br>
<br>

## UNIX Signals

### signal

1. 이름

- signal -- 단순화된 소프트웨어 signal 기능이다.  

<br>

2. 라이브러리

- 표준 C 라이브러리

<br>

3. 시놉시스


```c++
#include <signal.h>

void (*signal(int sig, void (*func)(int)))(int);

//또는 typedef된 버전에서 더 쉽게 정의된 경우에는

typedef void (*sig_t) (int);
sig_t signal(int sig, sig_t func);
```

로 정의되어 있다.

<br>

4. 설명

signal() 기능은 더 일반적인 sigaction기능의 단순화된 인터페이스이다.  

Signal들은 자신의 범위(domain) 바깥에서 프로세스의 조작을 허용한다.  
프로세스가 자기 자신을 조작하거나, 자기 자신의 복사본(children)을 조작하는 것을 허용한다.  

이런 signal에는 2가지의 종류가 있는데,  

1. 프로세스를 종료시킨다.
2. 프로세스를 종료시키지 않는다.

이렇게 프로세스의 종료를 유발하는 signal은`복구할 수 없는 에러`나,  
유저가 `interrupt character`를 입력함에 따라 발생한다.  

프로세스가 정지될 때 사용되는 signal은 프로세스가 `control terminal`에 접근하기 위해 사용된다.  

signal들은 프로세스가 멈춘 후에 재개되거나, child process(자식 프로세스)의 상태가 변경되거나, control terminal에서의 입력이 준비되면 선택적으로 생성된다.  

대부분의 signal들은 아무런 action이 발생하지 않는다면 signal을 수신하는 프로세스를 종료시킨다.  
일부 signal은 signal을 수신하는 프로세스들을 멈추거나, 프로세스가 요청하지 않았다면 페기되기도 한다.  

`SIGKILL, SIGSTOP`signal을 제외하고는 signal()함수는 signal을 잡아내거나, 무시하거나, interrupt를 생성하는 것을 허용한다.  

아래의 signal들은 signal.h헤더에 정의되어있다.  

```     
     No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace trap
     6     SIGABRT      create core image    abort program (formerly SIGIOT)
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    kill program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    write on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       continue after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background read attempted from control terminal
     22    SIGTTOU      stop process         background write attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2
```

<br>

```c++
void (*signal(int sig, void (*func)(int)))(int);
```

위 함수의 프로토타입에서 받는 인자를 확인해보자.  
sig 인자는 어떤 signal이 받아졌는지를 확인하고, func는 위의 signal종류 중에서 행할 action을 선택하게끔 한다.  

위에서 나열된 signal의 기본 동작을 설정하기 위해선, func는 `SIG_DFL`이어야한다.  
`SIG_DFL`은 기본 동작을 초기화한다.  

signal을 무시하기 위해선, func는 `SIG_IGN`이 되어야한다.  
이걸 인자로 넣게되면, 후속 instance는 무시되고, 보류중인 instance는 폐기된다.  
만약 `SIG_IGN`이 사용되지 않는다면, 추가 signal은 자동적으로 차단되고 `func`가 호출된다.  

처리되는 신호는 함수가 리턴되면 차단해제되고, 프로세스는 signal이 발생했을 때 끝났던 곳부터 계속된다.  
위에 봤던 signal 기능들과는 달리, signal이 전달된 후에도 핸들러 func()함수가 설치된 상태로 유지된다.  

몇몇 시스템콜에 대해, 시스템콜이 진행중이거나, 시스템콜이 조기 종료되면 시스템콜이 자동으로 재시작되기도 한다.  

signal(3)로 설치된 핸들러들은 `SA_RESTART` 플래그가 설정되어있는데, 이는 재시작 가능한 시스템콜은 signal이 수신돼도 반환되지 않는다.  

영향을 받는 시스템콜의 종류로는 read, write, sendto 등이 있는데, 이미 커밋된 시스템콜은 재시작되지 않는다. 대신, 부분적인 성공을 반환하는데, read의 경우 마지막에 버퍼사이즈보다 작은 크기를 읽어오면 리턴값이 버퍼사이즈보다 작아진다. 이를 의미한다.  

signal 핸들러가 설치된 프로세스가 `fork`를 하면 자식 프로세스는 이 signal들을 상속한다.  
모든 signal들은 execve함수 호출에 의해 기본 동작으로 리셋된다.  

만약 프로세스가 SIGCHLD signal에 대한 행동으로 SIG_IGN을 명시적으로 지정한 경우, 시스템은 자식 프로세스가 종료될때 zombie 프로세스를 생성하지 않는다.  
결과적으로, 시스템은 자식프로세스로부터의 exit 상태를 무시한다.  

만약 호출 프로세스가 뒤에 `wait`과 같은 호출을 할 경우, process의 자식 프로세스가 종료되기 전까지 block을 할 것이고, -1을 리턴하고 errno를 `ECHLD`로 설정한다.  

sigaction 메뉴얼에 signal 핸들러로 안전하게 사용할 수 있는 함수의 목록이 나와있다.  



5. 반환값

함수호출에 성공하면 이전의 action이 반환된다. 다른 경우, `SIG_ERR`이 반환되고, 전역변수 `errno`가 그 에러를 나타내기 위해 설정된다.  



<br><br>

### sigaction

1. 시놉시스

```c++
#include <signal.h>

struct sigaction {
	union __sigaction_u __sigaction_u; //signal 핸들러
	sigset_t	sa_mask; //적용하기위한 siganl mask
	int			sa_flags; //signal 옵션 확인하세요
};

union __sigaction_u {
	void	(*__sa_handler)(int);
	void	(*__sa_sigaction)(int, siginfo_t *, void *);

};

#define sa_hander		__sigaction_u.__sa_handler
#define sa_sigaction	__sigaction_u.__sa_sigaction

int	sigaction(int sig, const struct sigaction *restrict act, 
		struct sigaction *restrict oact);
```
<br>

2. 설명

시스템은 프로세스로 전달될 수 있는 signal들을 정의해놨다.  
Signal 전달은 hardware interrupt발생과 비슷한데, signal은 신호가 더 이상 발생되지 않도록 block하고, 현재 프로세스의 context가 저장되고, 새로운 것이 만들어진다.  
프로세스는 signal이 전달되는 핸들러를 지정하거나, 무시될 signal을 지정할 수 있다.  
또한, signal이 발생할 때, 시스템에서 기본 동작을 하도록 지정할 수 있다.  또한 signal이 unblock될때까지 신호의 전달을 연기하도록 block을 할 수도 있다.  
전달을 수행할 때의 행동은 전달 시점에 결정된다.  
일반적으로 signal 핸들러들은 프로세스의 현재 스택에서 실행된다.  
이는 핸들러별로 signal이 special signal stack에서 받아지도록 변경될 수 있다.  

<br>

signal 루틴은 호출의 원인이된 signal을 차단한 상태에서 실행되지만, 다른 signal들은 여전히 발생할 수 있다.  
전역 `signal mask`는 프로세스로 전달되는 현재 차단된 signal set을 정의한다.  
프로세스를위한 signal mask는 일반적으로 비어있는데, 프로세스의 부모의 signal mask에서 초기화된다.  
`sigprocmask`가 호출되면 변경될 수 있고, 프로세스에 signal이 전달됨에따라 바뀔 수 있다.  

<br>

프로세스에 대한 signal 조건이 발생하면 해당 signal은 프로세스를 위해 대기중인 signal에 추가된다.  
만약에 해당 signal이 해당 프로세스에 의해 block되지 않는다면 process에 전달되게된다.  
signal들은 프로세스가 OS(시스템콜, page fault, trap, clock interrupt 등)에 진입할 때마다 전달될 수 있다.  
만약에 복수의 signal들이 동시에 전달될 준비가 되어있다면 trap으로 인해 발생할 수 있는 냐후미dl rkwkd ajswj wjsekfehlsek.  
추가적인 signal들도 동시에 처리될 수 있는데, 각각은 첫 번째 지시 전에 이전 signal의 핸들러를 interrupt하는 것처럼 보인다.  
보류중인 signal들의 집합은 sigpending 시스템콜에의해 반환된다.  
잡힌 신호가 전달되면, 현재 프로세스의 상태는 저장되며, 새로운 signal mask가 계산되고, 해당하는 signal 핸들러가 발생된다.  

핸들러에 대한 호출은 signal 핸들링 루틴이 정상적으로 반환되는 경우에 신호가 전달되기 전의 context에서 프로세스가 다시 실행되도록 배열된다.  
프로세스가 다른 context에서 다시 시작하려는 경우, 이전 context를 복원하도록 노력해야한다.  


signal이 프로세스에 전달되면 새로운 signal mask가 프로세스의 signal 핸들러 동안 설치된다.  
이 mask는 현재 signal mask set, 전달될 signal, 호출될 핸들러와 연결된 signal mask의 조합을 취해 형성된다.  

sigaction 시스템콜 함수는 sig로 식별되는 signal에 action을 할당할 수 있다.  
만약 act가 non-zero라면, 기것은 action을 식별하고, 식별된 signal을 전달하면서 사용될 mask를 식별한다.  
만약 oact가 non-zero라면, 이전의 signal 핸들링 정보는 유저에게 반환된다.  




₩




<br><br>

### sigemptyset

### sigaddset


### kill


### getpid



### pause

### sleep

### usleep
