---
title: "minitalk(1)"
excerpt: "Small data exchange program using UNIX signals"

categories:
  - minitalk
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-05-05
last_modified_at: 2022-05-05
---

<br><br>

## Process

### 용어

- process
  시스템 상에서 현재 구동되고 있는 컴파일된 소스코드를 의미한다.  
  예를들어, C, C++로 프로그램을 작성해 컴파일하면 컴퓨터가 이해할 수 있는 바이너리 코드를 생성하는데, C, C++로 작성된 코드와 바이너리 코드는 모두 프로그램이다.  
  그리고, 이 바이너리 코드를 실행하면 프로세스가 된다.
  <br>
  프로그램은 수동 엔터티로 간주되지만, 프로세스는 능동 엔터티로 간주된다.  
  하나의 프로그램은 여러 번 실행됨에따라 많은 프로세스를 생성할 수 있다.(fdf를 여러개 실행할 수 있듯...)

  프로세스가 실행되면, 메모리에 프로세스가 올라가게되는데, 코드는 text영역, 전역변수는 data영역, 지역변수와 매개변수 등은 stack, 동적할당된 메모리는 heap으로 나뉘게된다.

<br>

- process 상태
  process의 상태는 7개 중 1개에 해당된다.
  1. new : 새로 생성된, 생성 중인 프로세스.
  2. ready : 생성된 프로세스가 준비상태로 이동함. 실행할 준비가 완료됨
  3. run : CPU에서 작동중인 프로세스.
  4. wait(or block) : 프로세스가 I/O access를 요청함
  5. Complete(or Terminated) : 프로세스가 실행을 완료함
  6. Suspended Ready : ready queue가 꽉찼을 때, 몇몇 프로세스는 suspended ready state로 이동함.
  7. Suspended Block : waiting queue가 꽉찼을 때, 상동.

<br>

- PID
  모든 프로세스는 process id, PID를 가지고 있다.

<br>
- PPID
  각각의 프로세스는 부모 프로세스(PPID)를 가지고 있으며, 자식 프로세스는 종종 부모 프로세스에 의해 시작된다.

<br>
- init
  init 프로세스는 항당 ID 1번을 가지고 있다.  
  init 프로세스는 kernel에 의해 시작되며, 이에따라 부모프로세스가 기술적으로 존재하지 않게된다.(모든 프로세스가 부모 프로세스를 가지고 있음에도 불구하고)  
  init은 고립된 프로세스들(orphaned processes)의 양부모 역할을 한다.

<br>
- kill
  process가 멈추거나, 죽거나, 죽고싶을 때, kill로 프로세스를 없앨 수 있다.

<br>
- daemon
  시스템이 시작될 때, 같이 시작되면서 영원히 구동되는 프로세스들을 daemon process라고 부른다. 
  이 daemon process들은 절대로 죽지 않는다.

<br>
- zombie
  프로세스가 죽었는데, 시스템상에서 아직 보인다면, zombie프로세스라고 불린다.  
  zombie프로세스들은 이미 죽은 상태이므로 kill할 수 없다.

<br>

### 기본적인 프로세스 관리

- $$, PPID
  몇몇 쉘 환경변수는 프로세스에 대한 정보를 가지고 있다.  
  $$변수는 현재 PID에 대한 정보를 가지고 있고,  
  $PPID 변수는 부모의 PID를 가지고 있다.  
  정확하게는, $$은 쉘의 변수가 아닌 쉘 인자이기 때문에 값을 할당할 수 없다.

  ```sh
  echo $$ $PPID
  ```

<br>
- pidof
  pidof 명령어를 통해 이름으로 모든 프로세스의 아이디들을 찾을 수 있다.

  ```sh
  pidof mingetty
  ```

<br>
- parent, child 부모와 자식

  프로세스들은 부모-자식 관계를 가지고 있다.
  그리고 모든 프로세스들은 부모 프로세스를 가지고 있다.(init제외)
  예시가 있는데,  

  ```sh
  echo $$ $PPID
  zsh
  echo $$ $PPID
  exit
  echo $$ $PPID
  ```

  위 명령어의 결과를 보게되면,  
  
  ```
  myukang@c4r8s1 ~ % echo $$ $PPID 
  81206 81044
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  81260 81206
  myukang@c4r8s1 ~ % exit
  myukang@c4r8s1 ~ % echo $$ $PPID
  81206 81044
  ```

  현재 쉘의 PID는 81206인데, zsh로 새로운 쉘을 만들어내니까  
  PID 81206을 부모로하는 자식 프로세스 81260을 만들어낸다.  
  그리고 exit로 만들었던 쉘을 종료하니, 다시 자기자신으로 돌아온 것을 볼 수 있다.  

<br>
- fork , exec
  프로세스는 다른 프로세스를 만들 때, 2가지 과정을 거친다.  
  첫 번째로, 프로세스는 동일한 사보인 자기 자신의 `fork`를 만들어낸다.  
  그리고 그 fork된 사본 프로세스는 `exec`을 실행해 fork된 프로세스를 target child process와 바꾼다.

<br>
- exec
  exec 명령어로, 새로운 프로세스를 fork할 필요 없이 프로세스를 실행할 수 있다.  
  exec은 특히, 현재 프로세스를 타겟 프로세스로 완전히 갈아끼우는데, 이에따라 현재 프로세스가 어떤 context에 있든 상관없이,  
  타겟 프로세스가 실행되고, 종료된다.
  
  ```sh
  myukang@c4r8s1 ~ % echo $$
  81206
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec bash
  bash-3.2$ echo $$ $PPID
  82241 81206
  bash-3.2$ exit
  exit
  myukang@c4r8s1 ~ % echo $$ 
  81206
  myukang@c4r8s1 ~ % 
  ```

<br>
<br>

## interrupts

interrupt를 이해하기 위해 bus를 먼저 보자.  

하드웨어 구성요소는 CPU와 통신할 때, bus를 이용하게된다.  
오늘날 흔히 사용되는 bus는 usb, pci, agp, pci-express 와 같은 `plug and play bus`들이다.  

<br>

interrupt에는 기본적으로 2가지의 interrupt가 있다.  

- software interrupt
- hardware interrupt

아래의 설명은 hardware interrupt이다.  


```
`interrupt request, IRQ`는 장치가 CPU에게 보내는 요청이다.  
장치가 CPU가 읽어야하는 데이터를 가지고 있을 때, CPU에게 집중을 요구하기 위해 `interrupt`를 발생시킨다.  

`irq`는 장치들간에 공유될 수 있다.  
Interrupt 0번은 timer를 위해 예약되어있으며, 1은 키보드를 위해 예약되어있다.  
2번은 IRQ 8 ~ 15번까지의 통로이다.  
```

<br>
<br>

## UNIX Signals

### signal

signal은 software interrupt의 일종이다.  

1. 이름

- signal -- 단순화된 소프트웨어 signal 기능이다.  

<br>

2. 라이브러리

- 표준 C 라이브러리

<br>

3. 시놉시스


```cpp
#include <signal.h>

void (*signal(int sig, void (*func)(int)))(int);

//또는 typedef된 버전에서 더 쉽게 정의된 경우에는

typedef void (*sig_t) (int);
sig_t signal(int sig, sig_t func);
```

로 정의되어 있다.

<br>

4. 설명

signal() 기능은 더 일반적인 sigaction기능의 단순화된 인터페이스이다.  

Signal들은 자신의 범위(domain) 바깥에서 프로세스의 조작을 허용한다.  
프로세스가 자기 자신을 조작하거나, 자기 자신의 복사본(children)을 조작하는 것을 허용한다.  

이런 signal에는 2가지의 종류가 있는데,  

1. 프로세스를 종료시킨다.
2. 프로세스를 종료시키지 않는다.

이렇게 프로세스의 종료를 유발하는 signal은`복구할 수 없는 에러`나,  
유저가 `interrupt character`를 입력함에 따라 발생한다.  

프로세스가 정지될 때 사용되는 signal은 프로세스가 `control terminal`에 접근하기 위해 사용된다.  

signal들은 
- 프로세스가 멈춘 후에 재개되거나
- child process(자식 프로세스)의 상태가 변경되거나
- control terminal에서의 입력이 준비되면 선택적으로 생성된다.  

대부분의 signal들은 아무런 action이 발생하지 않는다면 signal을 수신하는 프로세스를 종료시킨다.  
일부 signal은 signal을 수신하는 프로세스들을 멈추거나, 프로세스가 요청하지 않았다면 폐기되기도 한다.  

`SIGKILL, SIGSTOP`signal을 제외하고는 signal()함수는 signal을 잡아내거나, 무시하거나, interrupt를 생성하는 것을 허용한다.  

아래의 signal들은 signal.h헤더에 정의되어있다.  

```     
     No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace trap
     6     SIGABRT      create core image    abort program (formerly SIGIOT)
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    kill program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    write on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       continue after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background read attempted from control terminal
     22    SIGTTOU      stop process         background write attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2
```

<br>

```cpp
void (*signal)(int sig, void (*func)(int)))(int);
```

위 함수의 프로토타입에서 받는 인자를 확인해보자.  
sig 인자는 어떤 signal이 받아졌는지를 확인하고, func는 위의 signal종류 중에서 행할 action을 선택하게끔 한다.  

위에서 나열된 signal의 기본 동작을 설정하기 위해선, func는 `SIG_DFL`이어야한다.  
`SIG_DFL`은 기본 동작을 초기화한다.  

signal을 무시하기 위해선, func는 `SIG_IGN`이 되어야한다.  
이걸 인자로 넣게되면, 후속 instance는 무시되고, 보류중인 instance는 폐기된다.  
만약 `SIG_IGN`이 사용되지 않는다면, 추가 signal은 자동적으로 차단되고 `func`가 호출된다.  

처리되는 신호는 함수가 리턴되면 차단해제되고, 프로세스는 signal이 발생했을 때 끝났던 곳부터 계속된다.  
위에 봤던 signal 기능들과는 달리, signal이 전달된 후에도 핸들러 func()함수가 설치된 상태로 유지된다.  

몇몇 시스템콜에 대해, 시스템콜이 진행중이거나, 시스템콜이 조기 종료되면 시스템콜이 자동으로 재시작되기도 한다.  

signal(3)로 설치된 핸들러들은 `SA_RESTART` 플래그가 설정되어있는데, 이는 재시작 가능한 시스템콜은 signal이 수신돼도 반환되지 않는다.  

영향을 받는 시스템콜의 종류로는 read, write, sendto 등이 있는데, 이미 커밋된 시스템콜은 재시작되지 않는다.  
대신, 부분적인 성공을 반환한다. (read의 경우 마지막에 버퍼사이즈보다 작은 크기를 읽어오면 리턴값이 버퍼사이즈보다 작아진다.)  

signal 핸들러가 설치된 프로세스가 `fork`를 하면 자식 프로세스는 이 signal들을 상속한다.  
모든 signal들은 execve함수 호출에 의해 기본 동작으로 리셋된다.  

만약 프로세스가 SIGCHLD signal에 대한 행동으로 SIG_IGN을 명시적으로 지정한 경우, 시스템은 자식 프로세스가 종료될때 zombie 프로세스를 생성하지 않는다.  
결과적으로, 시스템은 자식프로세스로부터의 exit 상태를 무시한다.  

만약 호출 프로세스가 뒤에 `wait`과 같은 호출을 할 경우, process의 자식 프로세스가 종료되기 전까지 block을 할 것이고, -1을 리턴하고 errno를 `ECHLD`로 설정한다.  

sigaction 메뉴얼에 signal 핸들러로 안전하게 사용할 수 있는 함수의 목록이 나와있다.  


5. 반환값

성공하는 경우, 기존 handler의 function pointer가 리턴된다.  
실패하는 경우, `SIG_ERR`이 반환되고, 전역변수 `errno`가 그 에러를 나타내기 위해 설정된다.  



<br><br>

### sigaction

1. 시놉시스

```cpp
#include <signal.h>

struct sigaction {
	union __sigaction_u __sigaction_u; //signal 핸들러
	sigset_t	sa_mask; //적용하기위한 siganl mask
	int			sa_flags; //signal 옵션 확인하세요
};

union __sigaction_u {
	void	(*__sa_handler)(int);
	void	(*__sa_sigaction)(int, siginfo_t *, void *);
};

#define sa_hander		__sigaction_u.__sa_handler
#define sa_sigaction	__sigaction_u.__sa_sigaction

int	sigaction(int sig, const struct sigaction *restrict act, 
		struct sigaction *restrict oact);
```
<br>

2. 설명

시스템은 프로세스로 전달될 수 있는 signal들을 정의해놨다.  
Signal 전달은 hardware interrupt발생과 비슷한데, signal은 신호가 더 이상 발생되지 않도록 block하고, 현재 프로세스의 context가 저장되고, 새로운 것이 만들어진다.  
프로세스는 signal이 전달되는 핸들러를 지정하거나, 무시될 signal을 지정할 수 있다.  
또한, signal이 발생할 때, 시스템에서 기본 동작을 하도록 지정할 수 있다.  또한 signal이 unblock될때까지 신호의 전달을 연기하도록 block을 할 수도 있다.  
전달을 수행할 때의 행동은 전달 시점에 결정된다.  
일반적으로 signal 핸들러들은 프로세스의 현재 스택에서 실행된다.  
이는 핸들러별로 signal이 special signal stack에서 받아지도록 변경될 수 있다.  

<br>

signal 루틴은 호출의 원인이된 signal을 차단한 상태에서 실행되지만, 다른 signal들은 여전히 발생할 수 있다.  
전역 `signal mask`는 프로세스로 전달되는 현재 차단된 signal set을 정의한다.  
프로세스를위한 signal mask는 일반적으로 비어있는데, 프로세스의 부모의 signal mask에서 초기화된다.  
`sigprocmask`가 호출되면 변경될 수 있고, 프로세스에 signal이 전달됨에따라 바뀔 수 있다.  

<br>

프로세스에 대한 signal 조건이 발생하면 해당 signal은 프로세스를 위해 대기중인 signal에 추가된다.  
만약에 해당 signal이 해당 프로세스에 의해 block되지 않는다면 process에 전달되게된다.  
signal들은 프로세스가 OS(시스템콜, page fault, trap, clock interrupt 등)에 진입할 때마다 전달될 수 있다.  
만약에 복수의 signal들이 동시에 전달될 준비가 되어있다면 trap으로 인해 발생할 수 있는 signal이 가장 먼저 전달될 수 있다.  
추가적인 signal들도 동시에 처리될 수 있는데, 각각은 첫 번째 지시 전에 이전 signal의 핸들러를 interrupt하는 것처럼 보인다.  
보류중인 signal들의 집합은 sigpending 시스템콜에의해 반환된다.  
잡힌 신호가 전달되면, 현재 프로세스의 상태는 저장되며, 새로운 signal mask가 계산되고, 해당하는 signal 핸들러가 발생된다.  

핸들러에 대한 호출은 signal 핸들링 루틴이 정상적으로 반환되는 경우에 신호가 전달되기 전의 context에서 프로세스가 다시 실행되도록 배열된다.  
프로세스가 다른 context에서 다시 시작하려는 경우, 이전 context를 복원하도록 노력해야한다.  


signal이 프로세스에 전달되면 새로운 signal mask가 프로세스의 signal 핸들러 동안 설치된다.  
이 mask는 현재 signal mask set, 전달될 signal, 호출될 핸들러와 연결된 signal mask의 조합을 취해 형성된다.  

sigaction 시스템콜 함수는 sig로 식별되는 signal에 action을 할당할 수 있다.  
만약 act가 non-zero라면, 기것은 action을 식별하고, 식별된 signal을 전달하면서 사용될 mask를 식별한다.  
만약 oact가 non-zero라면, 이전의 signal 핸들링 정보는 유저에게 반환된다.  

일단 signal handler가 설치되면, 일반적으로 다른 sigaction() 시스템콜이나, execve(2) 가 수행되지 않는한, 유지된다.  
signal-specific 기본 동작은 SIG_DFL이라는 sa_handler를 설치해 초기화할 수 있다.  
기본저긍로 프로세스를 제거하지만, core dump와 함께, action없이, 프로세스를 중지하거나 계속하면서 제거할수도 있다.  
만약 sa_handler가 SIG_DFL이면, 해당 signal에 대한 기본동작은 signal을 무시하는 것이며, 만약 signal이 보류중이라면 보류된 signal은 해당 signal이 masked된 상태이더라도, 무시된다.  
만약 sa_handler가 SIG_IGN으로 설정되면 보류중인 signal은 무시되고 폐기된다.   


<br><br>

### sigaddset & sigemptyset

- NAME
     sigaddset, sigdelset, sigemptyset, sigfillset, sigismember – signal set을 조작한다.  

- LIBRARY
     Standard C Library (libc, -lc)

- SYNOPSIS
	```cpp
	#include <signal.h>

	#ifndef _ANSI_SOURCE
	typedef unsigned int sigset_t;
    
	int sigaddset(sigset_t *set, int signo);

    int sigdelset(sigset_t *set, int signo);

    int sigemptyset(sigset_t *set);

    int sigfillset(sigset_t *set);

    int sigismember(const sigset_t *set, int signo);
	```

- DESCRIPTION
	
	 아래의 함수들은 sigset_t에 저장된 signal set을 조작한다.  
	 sigemptyset, sigfillset은 다른 함수들이 사용되기 전에 sigset_t의 모든 객체에 머넞 사용되어야만한다.
	<br>
 	- The sigemptyset() 
		signal set을 초기화한다.  
	<br>
    - The sigfillset() 
		signal set을 모든 signal을 포함하도록 초기화한다.  
	<br>
    - The sigaddset()
		특정 signal의 signo를 signal set으로 추가한다.  
	<br>
    - The sigdelset() 
		특정 signo을 signal set에서 제거한다.  
	<br>
    - The sigismember()
		signal set에 특정 signal signo가 존재하는지 확인한다.  
		이 함수들은 signal.h 헤더에 매크로로 제공된다.

- RETURN VALUES
     
	 The sigismember() 함수는 set에 signal이 있으면 1, 없으면 0을 리턴한다.  
	 나머지 함수들은 모두 0을 리턴한다.  



### kill

- NAME
     kill – 프로세스에 signal을 전송

- SYNOPSIS
    
	```cpp
	#include <signal.h>

    int	kill(pid_t pid, int sig);
	```

- DESCRIPTION
     
	kill함수는 process나 process그룹에게 sig로 지정된 signal을 pid에 전송한다.  
	<br>
	일반적으로, sig는 sigaction(2)에 지정된 signal들 중 하나이다.  
	그러나, 값이 0이라면, error checking의 수행을 유발할거고, signal은 보내지지 않을것이다.  
	이는 pid의 유효성을 검사하는데에 쓰일 수 있다.  
	<br>
	프로세스가 pid에 의해 지정된 프로세스에 신호를 보낼 수 있는 권한을 가지려면, 
	수신 프로세스의 실제 또는 유효한 사용자 ID가 전송 프로세스의 ID와 일치하거나  
	사용자에게 적절한 권한이 있어야 한다(예: set-user-ID 프로그램에 의해 부여되거나 사용자가 슈퍼 사용자임).  
	유일한 예외사항으로는 signal 중, SIGCONT이며, 이는 항상 현재 프로세스의 하위 프로세스로 전달될 수 있습니다.
	<br>
	만약 pid가 0보다 크다면,  
		- Sig가 pid와 같은 ID를 가진 프로세스에게 전달된다.  
	<br>
	<br>
	pid가 0이라면. 
		- Sig가 그룹 ID가 송신자의 프로세스 그룹 ID와 같고 프로세스에 대한 권한이 있는 모든 프로세스로 전송된다.  
		- 이는 killpg(2)의 변형이다.
	<br>
	<br>
	만약 pid가 -1 이라면,  
		- 사용자에게 슈퍼 사용자 권한이 있는 경우, 신호는 시스템 프로세스와 신호를 보내는 프로세스를 제외한 모든 프로세스로 전송된다. 
		- 사용자가 슈퍼 사용자가 아닌 경우 신호를 보내는 프로세스를 제외하고 사용자와 동일한 uid로 모든 프로세스에 신호가 전송된다. 
		- 프로세스가 신호를 보낼 수 있으면 오류가 반환되지 않습니다.

<br><br>

### getpid

NAME
     getpid, getppid – get parent or calling process identification

SYNOPSIS
     #include <unistd.h>

     pid_t
     getpid(void);

     pid_t
     getppid(void);

DESCRIPTION
     getpid() returns the process ID of the calling process.  The ID is guaranteed to be unique and is useful for constructing temporary file names.

     getppid() returns the process ID of the parent of the calling process.

ERRORS
     The getpid() and getppid() functions are always successful, and no return value is reserved to indicate an error.

LEGACY SYNOPSIS
     #include <sys/types.h>
     #include <unistd.h>

     The include file <sys/types.h> is necessary.


### pause

- NAME
     pause – signal이 들어올때까지 정지

- LIBRARY
     Standard C Library (libc, -lc)

- SYNOPSIS
    
	```cpp
	#include <unistd.h>

    int pause(void);
	```

- DESCRIPTION
     
	Pause is made obsolete by sigsuspend(2).
	Pause는 `sigsuspend(2)`에 의해 더이상 사용되지 않는다.  
	pause 함수는 쓰레드가 interval timer나 kill 함수로부터 signal을 받을때까지 기다리도록 요청한다.  
	pause() 도중에 signal handler의 제거가 시작되면 pause가 -1을 리턴한다.  

- RETURN VALUES
     Always returns -1.

<br><br>

### sleep


NAME
     sleep – suspend execution for an interval of time

SYNOPSIS
     sleep seconds

DESCRIPTION
     The sleep command suspends execution for a minimum of seconds.

     If the sleep command receives a signal, it takes the standard action.  When the SIGINFO signal is received, the estimate of the amount of seconds left to sleep is
     printed on the standard output.

IMPLEMENTATION NOTES
     The SIGALRM signal is not handled specially by this implementation.

     The sleep command allows and honors a non-integer number of seconds to sleep in any form acceptable by strtod(3).  This is a non-portable extension, but is also
     implemented in GNU sh-utils since version 2.0a (released in 2002).

EXIT STATUS
     The sleep utility exits 0 on success, and >0 if an error occurs.

EXAMPLES
     To schedule the execution of a command for x number seconds later (with csh(1)):

           (sleep 1800; sh command_file >& errors)&

     This incantation would wait a half hour before running the script command_file.  (See the at(1) utility.)

     To reiteratively run a command (with the csh(1)):

           while (1)
                   if (! -r zzz.rawdata) then
                           sleep 300
                   else
                           foreach i (`ls *.rawdata`)
                                   sleep 70
                                   awk -f collapse_data $i >> results
                           end
                           break
                   endif
           end

   The scenario for a script such as this might be: a program currently running is taking longer than expected to process a series of files, and it would be nice to have
     another program start processing the files created by the first program as soon as it is finished (when zzz.rawdata is created).  The script checks every five minutes
     for the file zzz.rawdata, when the file is found, then another portion processing is done courteously by sleeping for 70 seconds in between each awk job.

<br><br>

### usleep

NAME
     usleep – suspend thread execution for an interval measured in microseconds

LIBRARY
     Standard C Library (libc, -lc)

SYNOPSIS
     #include <unistd.h>

     int
     usleep(useconds_t microseconds);

DESCRIPTION
     The usleep() function suspends execution of the calling thread until either microseconds microseconds have elapsed or a signal is delivered to the thread and its
     action is to invoke a signal-catching function or to terminate the process.  System activity or limitations may lengthen the sleep by an indeterminate amount.

     This function is implemented using nanosleep(2) by pausing for microseconds microseconds or until a signal occurs.  Consequently, in this implementation, sleeping has
     no effect on the state of process timers, and there is no special handling for SIGALRM.  Also, this implementation does not put a limit on the value of microseconds
     (other than that limited by the size of the useconds_t type); some other platforms require it to be less than one million.

NOTE
     The usleep() function is obsolescent.  Use nanosleep(2) instead.

RETURN VALUES
     The usleep() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.

ERRORS
     The usleep() function will fail if:

     [EINTR]            A signal was delivered to the process and its action was to invoke a signal-catching function.

SEE ALSO
     nanosleep(2), sleep(3)

HISTORY
     The usleep() function appeared in 4.3BSD.
