---
title: "minitalk(1)"
excerpt: "Small data exchange program using UNIX signals"

categories:
  - minitalk
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-05-05
last_modified_at: 2022-05-05
---

<br><br>

## Process

### 용어

- process
  시스템 상에서 현재 구동되고 있는 컴파일된 소스코드를 의미한다.  
  예를들어, C, C++로 프로그램을 작성해 컴파일하면 컴퓨터가 이해할 수 있는 바이너리 코드를 생성하는데, C, C++로 작성된 코드와 바이너리 코드는 모두 프로그램이다.  
  그리고, 이 바이너리 코드를 실행하면 프로세스가 된다.
  <br>
  프로그램은 수동 엔터티로 간주되지만, 프로세스는 능동 엔터티로 간주된다.  
  하나의 프로그램은 여러 번 실행됨에따라 많은 프로세스를 생성할 수 있다.(fdf를 여러개 실행할 수 있듯...)

  프로세스가 실행되면, 메모리에 프로세스가 올라가게되는데, 코드는 text영역, 전역변수는 data영역, 지역변수와 매개변수 등은 stack, 동적할당된 메모리는 heap으로 나뉘게된다.

- process 상태
  process의 상태는 7개 중 1개에 해당된다.
  1. new : 새로 생성된, 생성 중인 프로세스.
  2. ready : 생성된 프로세스가 준비상태로 이동함. 실행할 준비가 완료됨
  3. run : CPU에서 작동중인 프로세스.
  4. wait(or block) : 프로세스가 I/O access를 요청함
  5. Complete(or Terminated) : 프로세스가 실행을 완료함
  6. Suspended Ready : ready queue가 꽉찼을 때, 몇몇 프로세스는 suspended ready state로 이동함.
  7. Suspended Block : waiting queue가 꽉찼을 때, 상동.

- PID
  모든 프로세스는 process id, PID를 가지고 있다.

- PPID
  각각의 프로세스는 부모 프로세스(PPID)를 가지고 있으며, 자식 프로세스는 종종 부모 프로세스에 의해 시작된다.

- init
  init 프로세스는 항당 ID 1번을 가지고 있다.  
  init 프로세스는 kernel에 의해 시작되며, 이에따라 부모프로세스가 기술적으로 존재하지 않게된다.(모든 프로세스가 부모 프로세스를 가지고 있음에도 불구하고)  
  init은 고립된 프로세스들(orphaned processes)의 양부모 역할을 한다.

- kill
  process가 멈추거나, 죽거나, 죽고싶을 때, kill로 프로세스를 없앨 수 있다.

- daemon
  시스템이 시작될 때, 같이 시작되면서 영원히 구동되는 프로세스들을 daemon process라고 부른다. 
  이 daemon process들은 절대로 죽지 않는다.

- zombie
  프로세스가 죽었는데, 시스템상에서 아직 보인다면, zombie프로세스라고 불린다.  
  zombie프로세스들은 이미 죽은 상태이므로 kill할 수 없다.

<br>

### 기본적인 프로세스 관리

- $$, PPID
  몇몇 쉘 환경변수는 프로세스에 대한 정보를 가지고 있다.  
  $$변수는 현재 PID에 대한 정보를 가지고 있고,  
  $PPID 변수는 부모의 PID를 가지고 있다.  
  정확하게는, $$은 쉘의 변수가 아닌 쉘 인자이기 때문에 값을 할당할 수 없다.

  ```sh
  echo $$ $PPID
  ```

- pidof
  pidof 명령어를 통해 이름으로 모든 프로세스의 아이디들을 찾을 수 있다.

  ```sh
  pidof mingetty
  ```

- parent, child 부모와 자식

  프로세스들은 부모-자식 관계를 가지고 있다.
  그리고 모든 프로세스들은 부모 프로세스를 가지고 있다.(init제외)
  예시가 있는데,  

  ```sh
  echo $$ $PPID
  zsh
  echo $$ $PPID
  exit
  echo $$ $PPID
  ```

  위 명령어의 결과를 보게되면,  
  
  ```
  myukang@c4r8s1 ~ % echo $$ $PPID 
  81206 81044
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  81260 81206
  myukang@c4r8s1 ~ % exit
  myukang@c4r8s1 ~ % echo $$ $PPID
  81206 81044
  ```

  현재 쉘의 PID는 81206인데, zsh로 새로운 쉘을 만들어내니까  
  PID 81206을 부모로하는 자식 프로세스 81260을 만들어낸다.  
  그리고 exit로 만들었던 쉘을 종료하니, 다시 자기자신으로 돌아온 것을 볼 수 있다.  

- fork , exec
  프로세스는 다른 프로세스를 만들 때, 2가지 과정을 거친다.  
  첫 번째로, 프로세스는 동일한 사보인 자기 자신의 `fork`를 만들어낸다.  
  그리고 그 fork된 사본 프로세스는 `exec`을 실행해 fork된 프로세스를 target child process와 바꾼다.

- exec
  exec 명령어로, 새로운 프로세스를 fork할 필요 없이 프로세스를 실행할 수 있다.  
  
  ```sh
  myukang@c4r8s1 ~ % echo $$
  81206
  myukang@c4r8s1 ~ % zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec zsh
  myukang@c4r8s1 ~ % echo $$ $PPID
  82241 81206
  myukang@c4r8s1 ~ % exec bash
  bash-3.2$ echo $$ $PPID
  82241 81206
  bash-3.2$ exit
  exit
  myukang@c4r8s1 ~ % echo $$ 
  81206
  myukang@c4r8s1 ~ % 
  ```

## interrupts

interrupt를 이해하기 위해 bus를 먼저 보자.  

하드웨어 구성요소는 CPU와 통신할 때, bus를 이용하게된다.  
오늘날 흔히 사용되는 bus는 usb, pci, agp, pci-express 와 같은 `plug and play bus`들이다.  

`interrupt request, IRQ`는 장치가 CPU에게 보내는 요청이다.  
장치가 CPU가 읽어야하는 데이터를 가지고 있을 때, CPU에게 집중을 요구하기 위해 `interrupt`를 발생시킨다.  

`irq`는 장치들간에 공유될 수 있다.  
Interrupt 0번은 timer를 위해 예약되어있으며, 1은 키보드를 위해 예약되어있다.  
2번은 IRQ 8 ~ 15번까지의 통로이다.  



<br>
<br>

## UNIX Signals

### signal

1. 이름

- signal -- 단순화된 소프트웨어 signal 기능이다.  

<br>

2. 라이브러리

- 표준 C 라이브러리

<br>

3. 시놉시스


```c++
#include <signal.h>

void (*signal(int sig, void (*func)(int)))(int);

//또는 typedef된 버전에서 더 쉽게 정의된 경우에는

typedef void (*sig_t) (int);
sig_t signal(int sig, sig_t func);
```

로 정의되어 있다.

<br>

4. 설명

signal() 기능은 더 일반적인 sigaction기능의 단순화된 인터페이스이다.  

Signal들은 자신의 범위(domain) 바깥에서 프로세스의 조작을 허용한다.  
프로세스가 자기 자신을 조작하거나, 자기 자신의 복사본(children)을 조작하는 것을 허용한다.  

이런 signal에는 2가지의 종류가 있는데,  

1. 프로세스를 종료시킨다.
2. 프로세스를 종료시키지 않는다.

이렇게 프로세스의 종료를 유발하는 signal은`복구할 수 없는 에러`나,  
유저가 `interrupt character`를 입력함에 따라 발생한다.  

프로세스가 정지될 때 사용되는 signal은 프로세스가 `control terminal`에 접근하기 위해 사용된다.  

signal들은 프로세스가 멈춘 후에 재개되거나, child process(자식 프로세스)의 상태가 변경되거나, control terminal에서의 입력이 준비되면 선택적으로 생성된다.  

대부분의 signal들은 아무런 action이 발생하지 않는다면 signal을 수신하는 프로세스를 종료시킨다.  
일부 signal은 signal을 수신하는 프로세스들을 멈추거나, 프로세스가 요청하지 않았다면 페기되기도 한다.  

`SIGKILL, SIGSTOP`signal을 제외하고는 signal()함수는 signal을 잡아내거나, 무시하거나, interrupt를 생성하는 것을 허용한다.  

아래의 signal들은 signal.h헤더에 정의되어있다.  

```     
     No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace trap
     6     SIGABRT      create core image    abort program (formerly SIGIOT)
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    kill program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    write on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       continue after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background read attempted from control terminal
     22    SIGTTOU      stop process         background write attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2
```

<br>

```c++
void (*signal(int sig, void (*func)(int)))(int);
```

위 함수의 프로토타입에서 받는 인자를 확인해보자.  
sig 인자는 어떤 signal이 받아졌는지를 확인하고, func는 위의 signal종류 중에서 행할 action을 선택하게끔 한다.  

위에서 나열된 signal의 기본 동작을 설정하기 위해선, func는 `SIG_DFL`이어야한다.  
`SIG_DFL`은 기본 동작을 초기화한다.  

signal을 무시하기 위해선, func는 `SIG_IGN`이 되어야한다.  
이걸 인자로 넣게되면, 후속 instance는 무시되고, 보류중인 instance는 폐기된다.  
만약 `SIG_IGN`이 사용되지 않는다면, 추가 signal은 자동적으로 차단되고 `func`가 호출된다.  

### sigemptyset

### sigaddset

### sigaction

### kill


### getpid



### pause

### sleep

### usleep
