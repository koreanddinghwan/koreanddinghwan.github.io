---
title: "[C] 인트로!"
excerpt: "C언어란"

categories:
  - c
tags:
  - [c, syntax]

toc: true
toc_sticky: true

date: 2022-01-06
last_modified_at: 2022-01-06
---

<br><br>

# C언어 시작하기 전에 알아둬야 하는 것

## CPU

컴퓨터는 일련의 연산을 하는 계산기.  
여기서 알아야 하는 건,

<br>

### 1. 누가 명령어를 읽는지?

CPU라는 중앙 처리 장치가 명령어를 읽어들이고, 처리한다.  
초당 10억번정도 가능하다.

CPU는 연산을 처리하기위한 장치이므로, 여기에 명령어들을 저장하거나 연산결과도 여기에 저장하면 좋겠지만,  
CPU에는 데이터를 저장할 공간이 넓지 않다.

CPU에는 기본적으로 `연산을 위한 저장장치`로 레지스터가 있는데, 64비트 CPU는 128바이트밖에 못 담는다.

<br>

### 2. 어디서 명령어를 읽는지?

그래서 CPU는 외부에서 명령어를 읽어들이는데, 그 장치를 RAM이라고 한다.

RAM에 실행할 명령어들을 저장하고 있다고, 연산 시 RAM에서 읽어들이게된다.

CPU가 램에서 데이터를 읽어들이기 위해선 RAM의 어디에서 데이터를 읽어들일지 알아야한다.

RAM에는 1byte짜리 데이터를 보관할 수 있는 수많은 방으로 구성되어있다.  
그리고 이 방에는 주소값이 할당되어 있는데, 16진수로 보통 표현된다.

RAM의 본명이 Random Access Memory 이다.  
임의 접근 메모리 라는 의미인데, 왜 이런 이름이 붙었냐하면, 위에 언급한 방의 어느 주소값이라도 동일한 시간으로  
접근할 수 있다는 것이다.

문제점은 RAM은 휘발성 메모리이기 때문에 전기가 끊기면 데이터가 모두 날라간다는 것이다.

이를 보완한게 SSD, HDD이다.

CPU <- RAM <- SSD,HDD

이렇게 단계를 거치다보면 CPU의 연산속도보다 CPU가 명령어를 불러오는 데에 시간이 더 걸리는 병목현상이 발생한다.

이를 보완한게 CPU의 캐시이다.

캐시는 CPU가 레지스터에 데이터를 빠르게 불러올 수 있는 저장공간이다.
L1, L2, L3 가 계층별로 존재하며 L1에 가까울수록 크기가 작고, 빠르다.

이런 캐시를 사용해 CPU는 여러가지 예측 알고리즘으로 미래에 불러올 데이터를 미리 불러와 빠른 명령처리가 가능케한다.

빠르게 동작하는 프로그램을 설계하기 위해선 캐시미스를 낮춰야한다.

<br>

### 3. 명령어는 어떻게 작성할까?

CPU가 이해하는 명령어 집합을 ISA라고한다.

ISA에는 여러가지 종류가 있지만, 공통적인 것은 2진 데이터(binary data)로 이뤄져 있다는 것이다.

그래서 이진데이터를 사람이 이해하기 쉽게 나타낸 것이 어셈블리이다.

CPU에서 RAM에 데이터를 쓰기 위해서는

- 램의 어디에다(주소) 쓸지
- 램에 무엇을 쓸지
- 램의 해당 위치부터 얼마만큼 공간에 쓸지

가 있다.

아래는 Intel x86의 CPU가 이해하는 어셈블리이다.

```asmb
mov     eax, 4660 # 0x1234의 십진법표현
mov     BYTE PTR [rax], 3
```

1문장은 eax라는 레지스터에 주소값 4660을 대입하라는 명령  
2문장은 rax라는 이름의 레지스터에 들어있는 값을 주소값으로 그 위치에 3을 대입해라 라는 의미이다.  
BYTE PTR은 전달한 주소값으로부터 1BYTE만큼의 데이터를 3으로 덮어씌우라는 의미이다.

즉, RAM 0x1234에 1BYTE만큼의 데이터를 3으로 덮어씌우라는 의미.

1BYTE가 아닌 4BYTE 영역에 3을 저장하고 싶다면,

```asmb
mov     eax, 4660 # 0x1234의 십진법표현
mov     DWORD PTR [rax], 3 #WORD =>2BYTE, Double WORD => 4BYTE
```

여기서 eax는 rax레지스터의 마지막 32비트를 의미한다.

이렇게 어셈블리로 작성하면 컴퓨터에게 즉각적으로 명령을 내릴 수 있다는 장점이 있지만, 난해하다.  
그래서 만들어진게 컴파일의 개념이다.  
사람이 이해할 수 있는 쉬운 언어로 명령어를 작성해 어셈블리로 바꿔주는 프로그램이 컴파일러다.

<br>

### 4. 명령어를 어떻게 읽어들일까?

CPU가 명령어를 작성하기 위해서는 그 명령어를 어디에선가 가져와야한다.  
그리고 이 행위를 프로그램을 실행한다라고 한다.

CPU가 계속 명령어를 처리하기 위해선 현재 램의 어디에서 명령어를 읽어야하는지 계속 알고 있어야한다.

그 역할을 하는 레지스터가 CPU에 있고, intel은 RIP이라는 레지스터이다.

운영체제가 HDD나 SSD의 데이터를 복사해 RAM에 넣어주고,  
이를 RIP 레지스터가 RAM에 복사되어있는 명령어에서 주소값을 가져와서 CPU가 계속 명령을 처리할 수 있게 한다.

CPU에서 명령어를 처리할 때, 주소값이 필요하다고 그랬다.  
CPU가 참조하는 메모리값이 중복되는 경우를 방지하기 위해 페이징이라는 방식이 사용된다.

CPU가 참조하는 주소값들은 CPU입장에서만 있는 것이고, 실제 RAM에 저장되어있는 주소값은 페이징에 의해 다른 메모리 주소로 변환된다.

CPU가 참조하는 주소값을 가상 메모리라고 부르며, 페이징에 의해 실제로 참조하게될 실제 메모리값을 물리메모리라고 부른다.
