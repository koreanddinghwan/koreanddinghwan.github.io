---
title:  "libft 시작"
excerpt: "mem형제들"

categories:
  - libft
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-03-07
last_modified_at: 2022-03-08
---
<br>

오늘 10시를 기준으로 첫 프로젝트가 언락됐다.  

일단 정독하고, 정리하면서 어떻게 문제를 풀어나갈지 고민해보자.  

mem 형제들을 구현하다보면, str형제들과 작동하는 방식이 매우 유사하다는 것을 알 수 있다.  
단, 여기서 알아야 할 점은, str형제들은 여기서 하는 일이 문자열을 검색한다는 것이고,  
mem 형제들은 바이너리 데이터까지 찾아낸다는 것이다.  


str형제들이 기존에 인덱싱을 하면서 널(NULL)값까지 돌리는 친구들이었지만,  
mem형제들은 바이너리 데이터들을 대상으로 하는 함수들임을 알아야한다.  
바이너리 데이터라 함은,,, 컴파일 됐을 때, ????이렇게 unsigned char로 표현되어 사람이 읽을 수 없는 코드를 본 적 있지 않나?  
vim으로 a.out이나 libft.a 같은 라이브러리 파일, ft_putchar.o 같은 컴파일된 파일을 확인해보면 읽을 수 없는데, 이 코드들이 바이너리 데이터(컴퓨터가 바로 읽을 수 있는 상태)라고 생각하면된다.  
바이너리 데이터는 말 그대로 2진수로 표현되어있는데이터들을 의미한다.(objdump -D ~.o로 확인해보자) 


# memset

- 프로토타입

```c++
void	*memset(void *b, int c, size_t len);
```

<br>

- 사용법

b(버퍼로 해석)에 unsigned char 로 변환된 c를 len 바이트만큼 작성한다.  
그리고 시작점을 리턴해준다.  

가령, 4바이트만큼의 메모리가 할당된 포인터 <b>p</b>가 있을 때,  
이 버퍼에 65를 4바이트만큼 작성한다면,  

```c++
p = memset(void *b, 65, 4);
```

각 바이트에 unsigned char 로 0 ~ 255만큼의 데이터를 넣을 수 있는데, 이렇게 초기화해줄 수 있다.  

<br>

프로토타입의 size_t 는 64비트 운영체제 기준으로 부호없는 8바이트 정수이다.  
왜 unsigned long이 아니라, size_t를 사용할까?  

stackoverflow에서 확인해보면, 코드의 이식성때문이다.  
long은 32비트 컴퓨터와 64비트 컴퓨터에서 각각 다른 바이트 크기를 가진다.  
이때, 만약 long이 없다면, 특정 프로그램을 짤 때 프로그래머들은 이 코드가 32비트 컴퓨터에서 컴파일 될 때와  
64비트 컴퓨터에서 컴파일 될 때를 모두 고려해 코드를 작성해야한다.  

근데, 만약 long을 사용한다면 그 자체로 <b>이 변수는 64bit에선 8바이트, 32bit에선 4바이트란다.</b>가 된다.  
난 이렇게 이해했다.....  

자, size_t는 각 컴퓨터의 운영체제별로 다른 크기의 자료형을 가지며,  
64빝 컴퓨터 기준으론 `unsigned long`이다!  

size_t가 선언되어있는 헤더는 `stddef.h`에 있다.  


<br>

- 주의사항

위에서 언급한 바와 같이 마지막 인자 len에는 unsigned long(뮬리넷이 64빝)이다.  
이때, 마지막 인자로 -1이 주어지면, 언더플로우가 생겨서 8바이트 수 끝으로 갈 것이다.  
테스트해보면,  

```c++
	b = malloc(sizeof(char) * 100);
	b = (char *)memset(b, '0', -1);
	

	printf("###memset\n");
	i = 0;
	while(i < 100)
{
	printf("i : %d, b : %d\n", i, *b);
	b++;
	i++;
}
```

<br>
결과값은  

```sh
i : 60, b : 48
i : 61, b : 48
i : 62, b : 48
i : 63, b : 48
i : 64, b : 0
```
정확하게 64번째까지만 복사해서 붙여넣는 것을 확인할 수 있다.  
왜? 이렇게 하는지는 의문이지만, 나름의 추측으로는 64바이트보다 큰 공간이 주어졌을때는 이렇게 사용할 수 있게 한 작은 배려가 아닐까 싶다.  
(누가 알 수 있을까?)  

암튼, memset은 여기까지,,,  

)))))추가. 
아이맥 환경에서 테스트해보니, -1 넣으면 원본함수에서도 세그폴트가 발생한다.  
위의 사항 고려 안해줘도 될 듯.  


<br><br>

# memcpy

- 프로토타입

```c++
void	*memcpy(void *restrict dst, const void *restrict src, size_t n);
```

<br>

- 사용법

n 바이트만큼 src 로부터 읽어서 dst에 복사한다.  
이때, dst와 src포인터가 겹치면 행동은 예측할 수 없다(undefined)  
src와 dst가 overlap될 수 있다면 memmove를 이용하시란다.  

이 함수는 리턴값으로 dst를 리턴한다.  
원본을 건드리지말고, 포인터를 복사해서 붙여넣기하고, 원본을 리턴해주자.  

- 주의사항  

특이하게, restrict와 const라는 키워드가 보인다.  

1. restrict

c99에서 새로 도입된 키워드이다.  
새로운 기능을 추가하기보다는 프로그래머에게 컴파일러가 할 수 있는 최적화에 대해 알린다.  
포인터에 이 제한 키워드가 사용되면, (`*restrict p`)  
해당 포인터만이 포인터가 가리키는 객체에 접근할 수 있는 방법임을 알린다.  
이에따라, 컴파일러가 확인하는 절차를 걸치지 않음으로써 최적화가 수행된다.  
프로그래머가 이를 어길 경우, 정의되지 않은 동작을 유발하게된다.  

근데, docs에서 이 키워드를 프로토타입에 포함하는 것을 금지하고있다.(다행)  

2. const

const 키워드는 자바스크립트에서도 쓰인다.  
흔히 말해 `상수`를 의미하는데, 한 번 선언되면 수정할 수 없음을 의미한다.  
단, 값을 읽어서 대입하는 행위는 허용되기때문에, 원본 데이터의 불변성을 지킬 수 있다.  
프로토타입에서 const로 받아왔기때문에, src자체를 수정할 수는 없으니, 다른 포인터를 선언해 dst에 대입하자!  

3. size_t n

memcpy는 특이하게 이 n이 dst에 할당된 메모리범위를 초과한 수가 들어올 경우, -Wall -Wextra -Werror 컴파일 옵션이 이를 방지해준다.  
감사히 여기도록하자.  


<br><br>

# memmove

- 프로토타입

```c++
void *memmove(void *dst, const void *src, size_t len);
```

<br>

- 사용법

src의 len 바이트만큼을 dest에 복사한다.  
중첩되는 오브젝트 간 복사를 혀용한다.  
이때, 원본이 손상되지 않는 방법으로 복사가 진행된다.  

- 주의사항

동일 포인터가 dst와 src에 주어질 경우, dst를 그대로 리턴하도록 하자.  

overlap된다는 것에 집중해보자.  





<br><br>

# memchr

- 프로토타입

```c++
void * memchr(const void *s, int c, size_t n);
```

- 사용법

인자로 주어진 s에서 unsigned char로 변환된 c가 첫번째로 나타나는 곳을 찾아낸다.  
찾아낸 바이트가 존재하는 포인터를 리턴하는데, 없으면 널포인터를 리턴한다.  

- 주의사항

이 역시 n으로 음수가 주어지면 세그폴트가 뜬다.  
따라서 양수가 올 때만 생각해주도록하자.  

또한 리턴해야하는 포인터의 경우, 찾으면 찾은 첫 문자의 포인터, 찾지 못하면 널포인터를 리턴해줘야한다는 것을 기억하자.   


<br><br>

# memcmp

- 프로토타입

```c++
int memcmp(const void *s1, const void *s2, size_t n);
```

- 사용법

s1와 s2를 바이트별로 비교한다.  
두 문자열 모두 n바이트 만큼 길다고 추측된다.  

두 문자열이 완전히 동일하다면 0을 리턴하지만, 다르다면 다른 두 바이트간의 차이를 리턴한다.  
이때 물론 unsigned char로 계산되어야하며, 길이가 0인 문자열은 항상 동일하다.  
:


- 주의사항

일반적으로 strncmp로 생각해서 구현하면 큰 오산이다.  
memcmp는 문자열을 비교하는 함수가 아닌, 바이너리 데이터를 비교하는 함수이다.  
따라서 구현 시, 널값을 고려해주는게 아니라, 값 자체만을 비교해서 달랐을 때 그 차이를 unsigned char 로 변환해 리턴해주면 된다.  






