---
title:  "libft 시작"
excerpt: "mem형제들"

categories:
  - libft
tags:
  - 42seoul

toc: true
toc_sticky: true

date: 2022-03-07
last_modified_at: 2022-03-08
---
<br>

오늘 10시를 기준으로 첫 프로젝트가 언락됐다.  

일단 정독하고, 정리하면서 어떻게 문제를 풀어나갈지 고민해보자.  


# memset

- 프로토타입

```c++
void	*memset(void *b, int c, size_t len);
```

<br>

- 사용법

b(버퍼로 해석)에 unsigned char 로 변환된 c를 len 바이트만큼 작성한다.  
그리고 시작점을 리턴해준다.  

가령, 4바이트만큼의 메모리가 할당된 포인터 <b>p</b>가 있을 때,  
이 버퍼에 65를 4바이트만큼 작성한다면,  

```c++
p = memset(void *b, 65, 4);
```

각 바이트에 unsigned char 로 0 ~ 255만큼의 데이터를 넣을 수 있는데, 이렇게 초기화해줄 수 있다.  

<br>

프로토타입의 size_t 는 64비트 운영체제 기준으로 부호없는 8바이트 정수이다.  
왜 unsigned long이 아니라, size_t를 사용할까?  

stackoverflow에서 확인해보면, 코드의 이식성때문이다.  
long은 32비트 컴퓨터와 64비트 컴퓨터에서 각각 다른 바이트 크기를 가진다.  
이때, 만약 long이 없다면, 특정 프로그램을 짤 때 프로그래머들은 이 코드가 32비트 컴퓨터에서 컴파일 될 때와  
64비트 컴퓨터에서 컴파일 될 때를 모두 고려해 코드를 작성해야한다.  

근데, 만약 long을 사용한다면 그 자체로 <b>이 변수는 64bit에선 8바이트, 32bit에선 4바이트란다.</b>가 된다.  
난 이렇게 이해했다.....  

자, size_t는 각 컴퓨터의 운영체제별로 다른 크기의 자료형을 가지며,  
64빝 컴퓨터 기준으론 `unsigned long`이다!  

size_t가 선언되어있는 헤더는 `stddef.h`에 있다.  


<br>

- 주의사항

위에서 언급한 바와 같이 마지막 인자 len에는 unsigned long(뮬리넷이 64빝)이다.  
이때, 마지막 인자로 -1이 주어지면, 언더플로우가 생겨서 8바이트 수 끝으로 갈 것이다.  
테스트해보면,  

```c++
	b = malloc(sizeof(char) * 100);
	b = (char *)memset(b, '0', -1);
	

	printf("###memset\n");
	i = 0;
	while(i < 100)
{
	printf("i : %d, b : %d\n", i, *b);
	b++;
	i++;
}
```

<br>
결과값은  

```sh
i : 60, b : 48
i : 61, b : 48
i : 62, b : 48
i : 63, b : 48
i : 64, b : 0
```
정확하게 64번째까지만 복사해서 붙여넣는 것을 확인할 수 있다.  
왜? 이렇게 하는지는 의문이지만, 나름의 추측으로는 64바이트보다 큰 공간이 주어졌을때는 이렇게 사용할 수 있게 한 작은 배려가 아닐까 싶다.  
(누가 알 수 있을까?)  

암튼, memset은 여기까지,,,  

<br><br>

# memcpy

- 프로토타입

```c++
void	*memcpy(void *restrict dst, const void *restrict src, size_t n);
```

<br>

- 사용법

n 바이트만큼 src 로부터 읽어서 dst에 복사한다.  
이때, dst와 src포인터가 겹치면 행동은 예측할 수 없다(undefined)  
src와 dst가 overlap될 수 있다면 memmove를 이용하시란다.  

이 함수는 리턴값으로 dst를 리턴한다.  
원본을 건드리지말고, 포인터를 복사해서 붙여넣기하고, 원본을 리턴해주자.  

- 주의사항  

특이하게, restrict와 const라는 키워드가 보인다.  

1. restrict

c99에서 새로 도입된 키워드이다.  
새로운 기능을 추가하기보다는 프로그래머에게 컴파일러가 할 수 있는 최적화에 대해 알린다.  
포인터에 이 제한 키워드가 사용되면, (`*restrict p`)  
해당 포인터만이 포인터가 가리키는 객체에 접근할 수 있는 방법임을 알린다.  
이에따라, 컴파일러가 확인하는 절차를 걸치지 않음으로써 최적화가 수행된다.  
프로그래머가 이를 어길 경우, 정의되지 않은 동작을 유발하게된다.  

근데, docs에서 이 키워드를 프로토타입에 포함하는 것을 금지하고있다.(다행)  

2. const

const 키워드는 자바스크립트에서도 쓰인다.  
흔히 말해 `상수`를 의미하는데, 한 번 선언되면 수정할 수 없음을 의미한다.  
단, 값을 읽어서 대입하는 행위는 허용되기때문에, 원본 데이터의 불변성을 지킬 수 있다.  
프로토타입에서 const로 받아왔기때문에, src자체를 수정할 수는 없으니, 다른 포인터를 선언해 dst에 대입하자!  

3. size_t n

memcpy는 특이하게 이 n이 dst에 할당된 메모리범위를 초과한 수가 들어올 경우, -Wall -Wextra -Werror 컴파일 옵션이 이를 방지해준다.  
감사히 여기도록하자.  


<br><br>

# memmove




<br><br>

# memchr




<br><br>

# memcmp




