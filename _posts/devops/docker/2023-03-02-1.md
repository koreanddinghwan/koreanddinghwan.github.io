---
title:  "[DOCKER] (번역)-Demystifying Containers - Part I: Kernel Space"
excerpt: "컨테이너 쉽게 이해하기"

categories:
  - docker
tags:
  - [kernel space]
  


toc: true
toc_sticky: true

date: 2023-03-02
last_modified_at: 2023-03-02
---

[원본 글](https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504)  


이 시리즈의 블로그 포스트와 이야기는 역사적인 관점에서 컨테이너에 대한 실용적인 관점을 제공하는 것을 목적으로 합니다.  
우리는 함께 현대 클라우드 아키텍처를 레이터별로 확인하게 될 것입니다.  
따라서 가장 하위 레이어인 리눅스 커널부터 시작해 자신만의 안전한 클라우드 네이티브 어플리케이션을 작성하는 것으로 끝날 것입니다.  


<br>

역사적 배경과 연결된 간단한 예시들은 최소한의 리눅스 환경으로 시작해 현재, 그리고 미래에 완벽하게 들어맞는 안전한 오케스트레이션(시스템과 소프트웨어의 자동화된 구성, 조율, 관리) 컨테이너를 만들 수 있게 해줄 것입니다.  
결국, 우리는 리눅스 커널, 컨테이너 도구, 런타임, 소프트웨어 정의 네트워크 및 쿠버네티스같은 오케스트레이션 소프트웨어의 기능이 어떻게 설계되고, 작동하는지 이해하는 것이 쉬워질 것입니다.  


<br><br>

# Part I: Kernel Space

이 첫번째 블로그 포스트는 리눅스 커널과 관련된 토픽을 초점을 맞추고 컨테이너에 대한 깊은 이해를 위한 기초를 제공할 것입니다.  
우리는 유닉스와 리눅스의 역사에 대한 인사이트를 얻을 것이고, chroot, namespace, cgroup등과 같은 솔루션에 대해 이야기 할 것 입니다.  
또한, 우리는 우리가 이야기할 미래의 주제에 대한 느낌을 얻기위해 컨테이너의 껍질을 벗길 것입니다.  


## Introduction

만약, 오늘날 우리가 컨테이너에 대해 이야기한다면, 대부분의 사람들은 큰 파란 고래나, 푸른 바탕에 하얀색 핸들을 생각할 것이다.

<img width="631" alt="스크린샷 2023-03-02 18 43 58" src="https://user-images.githubusercontent.com/76278794/222391737-27da3b88-f54a-4442-8d74-02f091a89282.png">


<br>

일단, 이 생각들을 제쳐두고, 스스로에게 물어봅시다.: 컨테이너가 구체적으로 뭔데?  
쿠버네티스에서 이에 관한 문서를 찾아본다면, [Why to use containers?](https://kubernetes.io/docs/concepts/overview/#why-containers), [그리고 수많은 도커 레퍼런스들](https://kubernetes.io/docs/concepts/containers/images/)에서 설명을 찾을 수 있습니다.  
도커는 자신 스스로 컨테이너를 [소프트웨어의 표준 단위](https://www.docker.com/resources/what-container/)라고 소개합니다.  
그들의 설명은 개괄적인 개요만 제공할 뿐, 근본적인 것을 드러내지는 않습니다.  
결국, 사람들은 컨테이너를 그저 값싼 가상머신이라는 기술적으로 들어맞지 않는 생각을 하게됩니다.  
그 이유는 컨테이너라는 단어가 아무것도 정확하게 뜻을 가지고있지 않기때문일 수 있고, 컨테이너 오케스트레이션 생태계에서의 pod도 똑같이 적용됩니다.  

<img width="682" alt="스크린샷 2023-03-02 18 52 41" src="https://user-images.githubusercontent.com/76278794/222393967-fe10eec6-1dfe-4ef4-978d-88ea055b1600.png">  

<br>

깊게 들어가면, `컨테이너는 단일 호스트에서 작동하는 프로세스의 격리된 그룹일 뿐이며, 이는 일반적인 특징을 만족합니다.`  
이러한 화려한 특징의 일부분은 리눅스 커널에 직접 만들어져있고, 대부분의 것들이 각각 다른 역사적 기원을 가지고 있습니다.  

그래서 컨테이너는 4가지의 주요 요구사항을 만족해야만합니다.

1. Not negotiable : 단일호스트에서만 실행되어야한다. 두 컴퓨터가 하나의 컨테이너를 실행시킬 수 없다.
2. Cleary : 그들은 프로세스의 그룹이다. 리눅스 프로세스들은 트리구조 내부에 있으며, 컨테이너는 반드시 root 프로세스가 필요하다.
3. Okay : 그들은 격리되어야한다. 이것의 의미는 나중에 설명.
4. Not to clear: 그들은 공통 특징을 만족하나, 일반적인 특징은 시간이 지남에따라 바뀐다. 따라서 우리는 공통 특징이 뭔지에 대해 집중해야한다.

<img width="725" alt="스크린샷 2023-03-02 19 10 04" src="https://user-images.githubusercontent.com/76278794/222398355-b6b51625-a3fa-430f-aaf6-d8156fedd973.png">

이러한 요구사항만으로는 혼란으로 이어지고, 위 그림은 아직 명확하지 않다.  
그러니, 이것들을 간단하게 하기 위해서 역사적인 측면부터 시작하자.  


<br><br>

# chroot

대부분의 유닉스 운영체제는 현재 실행중인 프로세스(그리고 자식 프로세스들)의 root 디렉토리를 바꿀 수 있는 가능성이 있다.  
이는 유닉스 버전7의 chroot의 등장을 기원으로한다.  
리눅스에서는 오늘날 chroot라는 시스템콜이나 독립형 래퍼 프로그램으로 실행할 수 있다.  
chroot는 감옥이라고 언급되기도 하는데, 왜냐하면 몇몇 사람들이 1991년에 이를 보안 해커를 감시하기위한 허니팟으로 사용했기 때문이다.  
그래서 chroot는 리눅스보다 훨씬 오래되었으며, 이는 2000년대 초반, 오늘날 우리가 마이크로서비스라고 부르는 방식의 어플리케이션을 실행시키기 위한 접근으로 사용되어왔다.  
chroot는 현재 다양한 종류의 어플리케이션에서 사용되고 있으며, 예를들어 다른 배포판을 위한 빌드서비스가 있다.  
오늘날, BSD 구현은 리눅스의 것과는 매우 다르며, 나중에 살펴볼 것이다.  

<br>

chroot 환경을 구동하기위해 필요한것은 무엇일까?  

```sh
> mkdir -p new-root/{bin,lib64}
> cp /bin/bash new-root/bin
> cp /lib64/{ld-linux-x86-64.so*,libc.so*,libdl.so.2,libreadline.so*,libtinfo.so*} new-root/lib64
> sudo chroot new-root
```

- 새로운 root 디렉토리를 만들고, 배시쉘과 의존성을 복사하고, chroot를 실행한다.  
- 이렇게 격리된 `jail`은 쓸모가 없다: 왜냐하면 우리가 사용할 수 있는건 `bash와 cd, pwd같은 빌트인 함수밖에 없기때문`이다.  


<img width="677" alt="스크린샷 2023-03-02 19 29 39" src="https://user-images.githubusercontent.com/76278794/222402947-8680f605-381a-46d4-8265-763e806124a6.png">

