---
title: "[C++] 예외처리(Exception Handling)"
excerpt: "C++에서 예외처리"

categories:
  - cpp
tags:
  - cpp
  - syntax

toc: true
toc_sticky: true

date: 2022-07-20
last_modified_at: 2022-07-20
---

<br>
<br>

REF : 윤성우의 열혈 C++

보통, 함수화를 (모듈화)를 하면서 가장 처음에 예외처리를 작성해 프로그램 실행도중에 일어날 수 있는 문제상황(SEGV)를 처리한다.  
기존에 C에선 예외처리를 하기위해 if~else문을 자주 이용했다.  
이렇게 if~else문을 이용한 예외처리는 간편하지만, 코드를 읽는 사람에게 있어선  
해당 코드가  

- 예외처리를 위한 코드인가?
- 프로그램 흐름을 구성하는가?

인지 쉽게 파악하지 못하게한다.  

하지만, C++에서는 구조적으로 예외처리를 할 수 있는 메커니즘을 제공한다.  


<br>

## C++의 예외처리

- 코드의 가독성과 유지보수성을 위한 메커니즘
- 예외처리를 프로그램 흐름에서 독립시킬 수 있다.

### try catch throw

- try   : 예외발생에 대한 검사 범위 지정
	```cpp
	try
	{
		//예외발생검사
	}
	```
	- try블록을 묶을때는 예외가 발생했을때 실행되지 않아야되는 코드도 넣어야한다.
- catch : try에서 발생한 예외를 처리하는 코드가 담긴 영역
	```cpp
	catch(처리할 예외 종류 명시)
	{
		//예외처리 코드 삽입
	}
	```
	- 항상 try블록 뒤에 이어서 등장해야한다.
- throw : 예외가 발생했음을 알리는 문장구성
	```cpp
	throw expn;
	```
	- expn은 어떤 데이터도 가능하지만, 예외상황에 대한 의미있는 문자여야한다.
	- throw한 예외데이터의 자료형과 catch에서 잡는 데이터의 자료형은 일치해야한다.


<br>
<br>


## Stack Unwinding

- throw에서 예외가 발생했지만, 바로 처리되지 않는경우.
- 함수 내부에서 throw를 해서 예외가 발생했으나, catch문이 없는 경우, 함수를 호출한 영역으로 예외처리 책임이 넘어간다.

```cpp
void myfunc(int num)
{
	if (num == 0)
		throw num;
	/*
	...예외 미발생시 처리할 코드
	*/
}

int main()
{
	...
	try
	{
		myfunc(num);
	}
	catch (int expn)
	{
		cout<<"예외발생"<<endl;
	}
}
```

- myfunc 내부에서 throw를 했지만, catch문이 함수 내부에 없어서 myfunc를 호출한 main으로 예외데이터가 전달된다.
- 이는 main의 catch문에서 처리된다.
- 이런 특성은 예외 발생위치와 처리위치가 다른 경우에 유용하다.
- 이런 현상을 `Stack Unwinding`(스택풀기)라고 한다.

<br>

### 깊은 스택풀기

```cpp
#include <iostream>
using namespace std;

void One(void);
void Two(void);
void Three(void);

int main(void)
{
	try {
		One();
	} catch (int expn) {
		cout<<"예외코드"<<expn<<endl;
	}
	return 0;
}

void One(void)
{
	cout<<"One()"<<endl;
	Two();
}

void Two(void)
{
	cout<<"Two()"<<endl;
	Three();
}

void Three(void)
{
	cout<<"Three()"<<endl;
	throw -1;
}
```

- three에서는 반드시 예외 -1이 throw된다.
- 함수의 스택이 반환되지만, 예외 데이터는 계속 전달되어 main으로 전달되게된다.
- main에서도 해당 예외가 처리되지 않았다면 `terminate함수에 의해`프로그램이 강제로 종료된다.
- int형 예외가 발생했지만, catch블록에서 char형으로 받는다면 해당 예외는 해당 catch블록에서 처리되지 않는다.

<br>

