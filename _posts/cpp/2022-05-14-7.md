---
title: "[C++] 정보은닉"
excerpt: "정보은닉"

categories:
  - cpp
tags:
  - cpp
  - syntax

toc: true
toc_sticky: true

date: 2022-05-14
last_modified_at: 2022-05-14
---

<br>
<br>

REF : 윤성우의 열혈 C++

## 정보은닉과 캡슐화

### 정보은닉의 이해

`제한된 방법으로의 접근만 허용해 잘못된 값이 저장되지 않도록 도와야한다.`  
`실수가 쉽게 발견되도록 해야한다.`

CPP에서 이를 위해서

- `멤버변수는 private로 선언한다.`
- `private에 접근할 수 있는 함수를 별도로 정의한다.`
- `이로써 안전한 형태로 변수 접근을 유도할 수 있다.`

<br>

### const 함수

- const 함수는 `멤버변수에 저장된 값을 변경하지 않겠다`라는 의미이다.  
	- 따라서, const선언이 추가된 멤버함수에서 멤버변수의 값을 변경한다면, 컴파일 에러가 발생한다.  
<br>

- const함수의 내에서는 `const가 아닌 함수 호출에 제한`이 생긴다.
	- const가 붙지 않은 함수는 멤버변수의 값을 변경할수도 있기때문이다.  
<br>

- const 참조자를 대상으로는 `const 함수만 호출`할 수 있다.
<br>

`const` 키워드를 많이 사용할수록 코드의 안정성이 높아진다.  


<br>

### 캡슐화

객체지향 프로그래밍에서 캡슐화는 2가지 측면이 있다.  

- 객체의 데이터와 기능을 하나로 묶고,
- 실제 구현 애용 일부를 내부에 감추어 은닉한다.  

이렇게 캡슐화에는 기본적으로 정보은닉이 포함된다.  

캡슐화를 하기 위해선, 어떤 데이터, 기능을 하나로 묶을 것인지를 결정해야한다.  
이에는 정답이 없고, 프로그램의 성격과 특성에 따라 달라진다.  
경험많은 프로그래머일수록 이것이 명확하다.  


<br>

## 생성자와 소멸자

생성자를 사용하면 객체를 생성하면서 동시에 멤버변수를 초기화할 수 있다.  


```cpp
class SimpleClass
{
private:
	int num;
public:
	SimpleClass(int n)
	{
		num = n;
	}
	int GetNum() const
	{
		return num;
	}
}
```

여기서 `SimpleClass(int n)`이라는 함수가 생성자이다.  
- 클래스의 이름과 함수의 이름이 동일하다.
- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.

이러한 유형의 `생성자`는 객체 생성시 딱 한번 호출된다.  
생성자가 가지는 특징으로는,  
1. 오버로딩이 가능하다.
2. 매개변수에 디폴트 값을 설정할 수 있다.

```cpp
SimpleClass()
{
	num1=0;
	num2=0;
}
SimpleClass(int n)
{
	num1=n;
	num2=0;
}
SimpleClass(int n1, int n2)
{
	num1=n1;
	num2=n2;
}
```

클래스 내부에 위와같은 생성자를 선언해두면,  
- 매개변수에 따른 함수오버로딩
- 디폴트값

을 정할 수 있게된다.
<br>