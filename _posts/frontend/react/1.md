# 1. 리액트 시작

## 1.1 why react?

자바스크립트는 웹 어플리케이션에서 가장 핵심적인 역할을 하며 규모가 큰 어플리케이션을 만들 수 있다.  
Angular, vue, Backbone, Derby, PureMVC 등등 수많은 웹 프레임워크가 애플리케이션 구조를 각각 다른 관점에서 이를 관리하기위해 노력해왔다.

이프레임워큳르은 주로 MVC, MVVM, MVW등등으로 애플리케이션을 구조화한다.
M: 모델, 애플리케이션에서 사용하는 데이터를 관리하는 영역,  
V: 뷰, 사용자에게 보이는 부분
C: 컨트롤러, 모델 데이터를 조회하거나 수정하고, 변경된 사항을 뷰에 반영한다.

데이터에 변화가 있으면 기존에 있던 것은 버리고, 새로 렌더링하면 편하겠지만, DOM은 느리고, 메모리사용량 증가, CPU점유율도 증가할 것이다. 그리고 사용자는 끊김현상을 인식할 것이다. 이러한 문제점을 위해 최대한 성능을 아끼고 편안한 User experience를 위해 개발한 것이 react이다.

### 1.1.1 리액트 이해

리액트는 사용자 인터페이스를 만드는 데 사용한다.  
구조가 MVC, MVM인 프레임워크와는 달리 V만 신경쓰는 라이브러리이다.

리액트 프로젝트에서 컴포넌트는 특정 부분의 생김세를 정한다.  
재사용 가능한 API로 수많은 기능을 내장하고, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의한다.

사용자에게 뷰를 보여주는 것을 렌더링이라고 한다.  
리액트는 어떤 방식으로 뷰를 렌더링해 성능을 아끼고, 최적의 사용자 경험을 제공할까?  
이는 리액트 컴포넌트가 최초로 실행하는 초기렌더링과 데이터변경에 의한 리렌더링의 개념 이해해야한다.

#### 1.1.1.1 초기렌더링

맨 처음에 어떻게 보일지 정하는 초기렌더링을 render()함수를 통해 정의한다.

이 함수는 컴포넌트가 어떻게 생겼는지 정의한다.  
이 함수는 뷰가 어떻게 생겼고, 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다.

1. 컴포넌트 내부에는 다른 컴포넌트가 들어갈 수 있기 때문에 render함수를 실행하면 내부의 컴포넌트둘도 재귀적으로 렌더링한다.

2. 최상위 컴포넌트의 렌더링이 끝나면 이 정보들로 HTML 마크업을 만들고,

3. 실제 페이지의 DOM요소에 주입한다.

#### 1.1.1.2 조화과정

리액트에서 뷰를 업데이트할때는 조화과정(reconciliation)을 거친다고 한다.  
컴포넌트가 데이터를 업데이트하면 새로운 데이터로 render함수를 호출한다. 그러면 이 데이터에 대한 뷰를 생성해낸다.  
이때, render함수가 반환하는 결과를 바로 DOM에 반영하는게 아니라, 이전에 render함수가 만들었던 컴포넌트 정보와 `최소한의 연산으로 비교하고 ` `최소한의 연산으로 둘의 차이를 알아내 DOM 트리를 업데이트한다.`

## 1.2 리액트의 특징

### 1.2.1. Virtual DOM

#### 1.2.1.1 DOM

DOM객체는 웹브라우저가 자바스크립트와 CSS를 적용할 수 있게 해준다.  
DOM은 트리형태라서 특정 노드를 찾고, 수정하고 제거가능함.

DOM의 문제점은 동적 UI에 최적화되어 있지 않다는 점이다.  
트위터나 페이스북을 예로들면, 스크롤을 내릴수록 많은 수많은 데이터가 로딩된다.  
규모가 큰 웹 애플리케이션에서 DOM에 직접 접근해 변화를 주면 성능이슈가 발생하게된다.

DOM을 조작할때마다 엔진이 웹 페이지를 새로 그리기 때문에 업데이트가 너무 잦으면 성능이 저하될 수 있다.  
리액트는 Virtual DOM방식을 이용해 DOM업데이트를 추상화하고, DOM 처리회수를 최소화해 효율적으로 진행한다.

#### 1.2.1.2 Virtual DOM

1. 초기렌더링 (DOM생성)
2. 데이터 업데이트 -> 업데이트된 데이터를 기반으로 Virtual DOM 생성
3. 이전 DOM과 Virtual DOM의 비교,
4. 바뀐부분만 적용

![다운로드](https://user-images.githubusercontent.com/76278794/144771425-978d4065-e9ca-43f5-b74d-025950c2a310.png)

Virtual DOM을 사용한다고 무조건 빠른 것은 아닌데, 작업이 매우 간단할때는 오히여 리액트를 사용하지 않는 편이 더 나은 성능을 보이기도한다.  
`리액트와 Virtual DOM이 언제나 제공할 수 있는 것은 업데이트 처리 간결성`이다.

### 1.2.2 기타 특징

다른 웹 프레임워크가 MVC, MVW 구조를 지향하는 것과 달리 리액트는 `V`만 담당한다.  
리액트는 프레임워크가 아닌 라이브러리이다.  
리액트에서 라우팅, Ajax처리, 상태관리등을 하기 위해서는 다른 라이브러리를 사용해야한다.
(라우팅-react-router, Ajax처리-axios,fetch, 상태관리- redux,mobx)

또 다른 웹프레임워크나 라이브러리와 혼용이 가능하다.  
Backbone, Angular 등의 프레임워크와 혼용이 가능하다.

## 1.3 설치(yarn)

```
1. Homebrew설치
2. brew update
3. brew install yarn
4. yarn config set prefix ~/.yarn
5. echo 'export PATH="$(yarn global bin):$PATH"' >> ~//bash_profile
```

### 1.3.1 CRA(create-react-app)

```
yarn create react-app . (현재폴더경로로 리액트프로젝트 생성)
yarn start (개발전용서버구동)
```

# 2. JSX

## 2.1 코드이해하기

src/App.js

```js
import logo from "./logo.svg";
import "./App.css";
import react from "react";

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

```js
import react from "react";
```

리액트를 불러와서 사용할 수 있게 해준다.  
리액트 프로젝트를 생성하면 node_modules라는 디렉터리가 생성되는데, cra프로젝트 생성과정에서 node_modules 디렉터리에 react 모듈이 설치되어 import로 가져와 사용하는것.

이렇게 모듈을 불러와서 사용하는 것은 원래 브라우저에는 없던 기능이다.  
브라우저가 아닌 환경에서 JS를 실행할 수 있게 해주는 환경인 Node.js에서 지원하는 기능이다.

이러한 기능을 브라우저에서 사용하기위해 bundler를 사용한다.
![다운로드 (1)](https://user-images.githubusercontent.com/76278794/144773806-cbf93ee4-e0b6-4db9-b741-6a5fd9eed693.png)

`index.js를 시작으로 연결된 컴포넌트들에서 필요한 모든 모듈을 불러와서 리액트는 webpack을 통해 bundling(묶기)를 한다.`
이런 번들러 도구를 사용하면 import로 모듈을 불러왔을때 불러온 모든 모듈을 합쳐 하나의 파일을 생성해준다.

```js
import logo from "./logo.svg";
import "./App.css";
```

웹팩을 사용하면 svg, css파일도 불러와서 사용할 수 있는데, 이런 기능을 담당하는 것은 웹팩의 loader라는 기능이다.
css-loader는 css파일을, file-loader는 웹폰트나 미디어파일을, babel-loader는 자바스크립트 파일을 불러와 최신 자바스크립트 문법코드를 babel로 ES5문법으로 변환해준다.

```js
function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}
export default App;
```

이 함수는 App이라는 컴포넌트를 생성한다. 이런 컴포넌트를 함수형 컴포넌트라고 부르는데, 프로젝트에서 컴포넌트를 렌더링하면 함수가 반환하고있는(return값)을 보여준다.  
이 return값에 html태그들이 보이는데, 이런 코드들을 JSX라고 부른다.

## 2.2 JSX란

JSX는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용해 일반 자바스크립트 형태의 코드로 변환된다.

```jsx
function App() {
    return (
        <div>
            Hello <b>react<b>
        </div>
    );
}
```

이렇게 JSX문법으로 작성된코드는 아래 js문법으로 변환된다

```js
function App() {
  return React.createElement(
    "div",
    null,
    "Hello",
    React.createElement("b", null, "react")
  );
}
```

컴포넌트를 렌더링할때마다 이렇게 일일히 createElement함수를 사용해야하면 매우 불편하다. JSX 코드의 효용성이 여기에 있다.

## 2.3 JSX의 장점

위에서 살펴봤듯, JSX코드는 많은 장점을 가지고 있다.

### 2.3.1 보기 쉽고 익숙하다.

JSX는 HTML요소를 직접적으로 표현할 수 있다.
JS만 이용한다면 createElement를 사용해야하기 때문에 개발자가 직관적으로 어떤 형태인지 확인하기 어려우나, JSX를 사용하면 HTML 코드를 보는것과 비슷하기에 직관적으로 확인할 수 있는 장점이 있다.

### 2.3.2 높은 활용도

위에서 우리가 작성한 App컴포넌트를 HTML태그 쓰듯이 그냥 작성한다.

```jsx
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);
```

-ReactDOM.render()
컴포넌트를 페이지에 렌더링하는 역할. react-dom 모듈을 불러와 사용한다.  
첫번째 매개변수로 렌더링할 내용을 JSX형태로 작성
두번째 매개변수로 렌더링할 위치(document 내부요소) 설정

-React.StrictMode
리액트 프로젝트에서 리액트의 레거시 기능들을 사용하지 못하게한다.
문자열 ref, componentWillMount같은 나중에 완전히 사라질 기능을 사용하면 경고출력.

## 2.4 JXS문법

### 감싸인요소

컴포넌트에 여러가지 요소가 있다면 반드시 부모요소 하나로 감싸야한다.

```jsx
import React from 'react';
function App() {
    return (
        <h1>hi</h1>
        <h2>react</h2>
    )
}
```

이렇게 여러 요소를 렌더링하면 안되고,

```jsx
import React from "react";
function App() {
  return (
    <div>
      <h1>hi</h1>
      <h2>react</h2>
    </div>
  );
}
export default App;
```

이렇게 부모요소 하나를 감싸주어야한다.

Virtual DOM에서 컴포넌트 변화를 감지할때 효율적으로 감지하기위해 각각 컴포넌트의 내부는 하나의 DOM 트리 구조로 이루어져야하는 규칙이 때문이다.

div대신에 `Fragment`라는 모듈을 사용할수도있다.

```jsx
import React from "react";
import { Fragment } from "react";

function App() {
  return (
    <Fragment>
      <h1>hi</h1>
      <h2>react</h2>
    </Fragment>
  );
}
export default App;
```

혹은 이런 형태도 가능하다

```jsx
import React from "react";
const App = () => {
  return (
    <>
      <h1>hi</h1>
      <h2>react</h2>
    </>
  );
};

export default App;
```

### 2.4.2 자바스크립트표현 사용하기

자바스크립트 표현식을 사용하기위해서는 JSX내부(컴포넌트가 렌더링하는 값, return값)에서 중괄호({})를 사용

```jsx
import react from "react";
const App = () => {
  const name = "리액트";
  return (
    <>
      <h1>hi</h1>
      <h2>{name}react</h2>
    </>
  );
};

export default App;
```

-ES6문법에서 var대신 const와 let이 사용된다.

```js
function myFuntion() {
  var a = "hello";
  if (true) {
    var a = "bye";
    console.log(a); // => bye
  }
  console.log(a); // => bye
}
myFuntion();
```

var을 사용하게되면 if문 안에서 변경한 값이 if문 밖에도 영향을 끼치게된다.  
이 점을 해결하기 위해 새로 나온 것이 const와 let이다.

```js
function myFuntion() {
  let a = "1";
  if (true) {
    let a = "2";
    console.log(a); // => 2
  }
  console.log(a); // => 1
}
myFuntion();
```

var는 함수단위, const와 let은 블록단위이기때문에 if문 내부블록에서 선언한 a값은 if문 밖의 a값을 변경하지 않는다.

let과 const를 사용할때 주의점으로는 -같은 블록 내부에서 중복선언이 불가능하다.
-const는 한번 선언하면 재설정할 수 없다.
가 있다.

ES6문법상에서 var를 사용할 일은 없기에  
`기본적으로 const를 사용하고, 값을 바꿔야한다면 let을 쓰자`

### 2.4.3 if문 대신 조건부 연산자.

JSX내부에서 if문을 사용할 수 없기에

1. JSX밖에서 사전에 값을 설정하거나
2. JSX내부에서 {} 중괄호 안에서 조건부 연산자를 사용하자.

JSX내부에서 조건부 연산자를 사용하는 방법

```jsx
function App() {
  const name = "리액트";
  return (
    <div>
      {name === "리액트" ? <h1>리액트입니다.</h1> : <h2>리액트가아닙니다.</h2>}
    </div>
  );
}
export default App;
```

조건부연산자는 다른말로 삼항연산자고도부르는데

```
{연산식 ? (연산식이 true일때) : (연산식이 false일때)}
```

이 방식으로 표현가능하다.

### 2.4.4 And연산사(&&)를 사용한 조건부 렌더링

개발할때 특정 조건을 모두 만족해야 내용을 보여주고, 만족하지 않으면 아무것도 렌더링하지 않아야할수도 있다.  
위에서 배운 조건부연산자를 사용해 null로 리턴할수도있지만

```jsx
{
  name === "리액트" ? <h1>리액트입니다.</h1> : null;
}
```

```jsx
{
  name === "리액트" && <h1>리액트입니다.</h1>;
}
```

이렇게 &&연산자로 조건부 렌더링을 할 수도 있다.  
여기서 주의해야할 점으로는 만약 0이 조건부로 들어가있다면 falsy한 값인 0은 예외적으로 화면에 나타난다.

```jsx
function App() {
  const number = 0;
  return <div>{number && <h1>리액트입니다.</h1>}</div>;
}
export default App;
```

위 코드는 화면에 0을 보여준다.

### 2.4.5 undefined 렌더링 방지

리액트에서는 함수가 undefined자체를 반환하여 렌더링하는 상황을 만들면 오류가 발생한다.

```jsx
function App() {
  const name = undefined;
  return name;
}
export default App;
```

이렇게 리턴값에 undefined자체가 렌더링되면 안되지만, jsx내부에서 undefined를 렌더링하는 것은 괜찮다.

```jsx
function App() {
  const name = undefined;
  return <div>{name}</div>;
}
export default App;
```

만약 어떤 값이 undefined일수도 있다면 OR(||)연산자로 undefined가 렌더링되는걸 방지할 수 있다.

```jsx
function App() {
  const name = undefined;
  return name || "값이 undefined입니다.";
}
export default App;
```

### 2.4.6 인라인 스타일링

리액트에서는 DOM요소에 스타일을 적용할때 문자열형태가아닌 객체형태로 넣어야한다.  
스타일 이름 중 `-`가 포함되는건 카멜표기법(대문자로 변환)을 사용한다.

```jsx
function App() {
  const name = "리액트";
  const style = {
    backgroundColor: "black",
    color: "aqua",
    fontSize: "48px",
    fontWeight: "bold",
    padding: "16px",
  };
  return <div style={style}>{name}</div>;
}
export default App;
```

const로 style객체를 먼저 만드는게 아니라 JSX내부에서 직접선언도 가능하다.

```jsx
function App() {
  const name = "리액트";
  return (
    <div
      style={{
        backgroundColor: "black",
        color: "aqua",
        fontSize: "48px",
        fontWeight: "bold",
        padding: "16px",
      }}
    >
      {name}
    </div>
  );
}
export default App;
```

### 2.4.7 class대신 className

보통 css는 css에서 클래스에 설정후, 스타일을 적용할 태그에 클래스를 부여한다.

```css
.react {
  background: aqua;
  color: black;
  font-size: 48px;
  font-weight: bold;
  padding: 16px;
}
```

```jsx
function App() {
  const name = "리액트";
  return <div className="react">{name}</div>;
}
export default App;
```

### 2.4.8 홀태그

HTML에서는 `<br>`이나 `<input>`처럼 받지 않은 상태로 코드를 작성할 수 있으나, 리액트는 열린코드가 닫히지 않으면 오류를 일으킨다.

선택지로

1. 열린 코드를 닫는다 <br></br>
2. 홀태그로 선언한다 <br />

### 2.4.9 주석

JSX내부에서 주석을 선언하기 위해서는 변수와같이 중괄호 {}안에 선언해주어야한다.

```jsx
function App() {
  const name = "리액트";
  return (
    <>
      {/* JSX내부의 주석 */}
      <div
        className="react" // 시작태그를 여러줄로 작성하면 여기에도 주석작성할 수 있습니다.
      >
        {name}
      </div>
      //이런 주석이나 /*이런 주석은 화면에 나타난다.*/
      <input />
    </>
  );
}
export default App;
```

# 3장 컴포넌트

## 3.1 클래스형 컴포넌트

리액트가 컴포넌트를 선언하는 방식은 함수형과 클래스형, 2가지이다.

```jsx
class App extends Component {
  render() {
    const name = "react";
    return <div className="react">{name}</div>;
  }
}
```

클래스형 컴포넌트에는 render함수가 반드시 있어야한다.

함수형 컴포넌트의 장점

- 함수형컨포넌트는 선언하기 훨씬 편하다.
- 메모리 자원을 클래스형보다 덜 사용한다.
- 프로젝트 빌드 후 배포시에도 함수형 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작다.

주요 단점으로 state와 라이프사이클 API사용이 불가능하다는 것이었는데, Hooks기능의 도입 이후 해결되었다.

리액트 공식 메뉴얼에서는 함수형, Hooks의 사용 권장하나 클래스형 컴포넌트가 사라진 것은 아니기에 알아두어야한다.

## 3.2 컴포넌트 생성

파일 만들기 -> 코드 작성하기 -> 모듈 내보내기 및 불러오기

### 3.2.1 src디렉터리에 MyComponents.js 생성

### 3.2.2 코드 작성

```jsx
import React from "react";

const MyComponent = () => {
  return <div>나의 새로운 컴포넌트</div>;
};
export default MyComponent;
```

ES6의 화살표 함수 문법으로 작성된 컴포넌트.

화살표 함수 문법은 이전에 function을 이용한 함수 선언 방식을 완전히 대체하지 못한다.  
이 둘의 차이는 서로가 가리키는 `this`의 값이 다르다는 점이다.

```js
function BlackDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: function () {
      console.log(this.name + "멍멍");
    },
  };
}

const blackDog = new BlackDog();
blackDog.bark();
//=> 검둥이 멍멍
```

일반 함수는 자신이 종속된 객체 자체를 가리키지만,

```js
function WhiteDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: () => {
      console.log(this.name + "멍멍");
    },
  };
}

const whiteDog = new WhiteDog();
whiteDog.bark();
//=>흰둥이 멍멍
```

화살표함수는 자신이 종속된 인스턴스를 가리킨다.

### 3.2.3 모듈 내보내기, 불러오기

#### 3.2.3.1 export

```jsx
export default MyComponent;
```

이 코드는 다른 파일에서 이 파일을 import하면 MyComponent 클래스를 불러오도록 설정한다.

#### 3.2.3.2 import

```jsx
import MyComponent from "./MyComponents";

const App = () => {
  return <MyComponent />;
};

export default App;
```

import 구문으로 현재 파일을 기준으로 해당 루트에서 MyComponent 컴포넌트를 불러온다.

## 3.3 props

props는 properties를 줄인 표현, 컴포넌트 속성 설정 시 사용하는 요소.  
A라는 컴포넌트의 props는 A의 부모컴포넌트에서 설정할 수 있음.

### 3.3.1~2 부모컴포넌트에서 자식컴포넌트로 props값 전달

```jsx
import MyComponent from "./MyComponents";

const App = () => {
  return <MyComponent name="react" />;
};

export default App;
```

부모 컴포넌트 App에서 props로 값을 전달한다.

```jsx
import React from "react";

const MyComponent = (props) => {
  return <div>나의 새로운 {props.name}컴포넌트</div>;
};
export default MyComponent;
```

자식 컴포넌트에서 `파라미터`로 받아와서 중괄호 형태로 사용한다.

### 3.3 기본값 설정

자식 컴포넌트 MyComponent가 파라미터로 props를 가져와서 사용하는데, 상위 컴포넌트에서 props가 따로 지정되지 않을때 보여줄 기본값은 defaultProps로 설정할 수 있다.

```jsx
import React from "react";

const MyComponent = (props) => {
  return <div>나의 새로운 {props.name}컴포넌트</div>;
};
MyComponent.defaultProps = {
  name: "홍길동",
};
export default MyComponent;
```

### 3.3.4 태그 사이의 내용 보여주는 children

태그 사이의 내용을 보여주는 props가 있다.

```jsx
import MyComponent from "./MyComponents";

const App = () => {
  return <MyComponent>children</MyComponent>;
};

export default App;
```

```jsx
import React from "react";

const MyComponent = (props) => {
  return (
    <div>
      나의 새로운 {props.name}컴포넌트
      <div>{props.children}이건 children props입니다.</div>
    </div>
  );
};
MyComponent.defaultProps = {
  name: "홍길동",
};
export default MyComponent;
```

부모컴포넌트에서 자식 컴포넌트를 호출할때, 태그 사이의 내용을 자식 컴포넌트에게 전달한다.

### 3.3.5 비구조화문법으로 필요한 props 추출

자식컴포넌트가 호출될때, console.log(props)를 해보면

```js
{children: 'children', name: '홍길동'}
```

props가 이와같은 객체를 전달하고 있음을 알 수 있다. 그래서 props.name, props.children으로 접근할 수 있었던 것인데,  
ES6의 비구조화 문법을 사용하면 컴포넌트 내부에서 바로 값을 추출해낼 수 있다.

```jsx
import React from "react";

const MyComponent = ({ name, children }) => {
  return (
    <div>
      나의 새로운 {name}컴포넌트
      <div>{children}이건 children props입니다.</div>
    </div>
  );
};
export default MyComponent;
```

props 파라미터로 전달받을때, 바로 변수에 할당해 return 할때 해당 변수로 직접적으로 나타낸다.  
props로 접근하는 것보다 더 직관적으로 컴포넌트 간 props전달을 확실히 알 수 있다.

### 3.3.6 propTypes통한 props 검증

컴포넌트의 필수 props를 지정하거나 props의 타입을 지정할때는 propTypes를 사용한다.  
코드 상단에 import로 불러와야한다.

```jsx
import React from "react";
import propTypes from "prop-types";

const MyComponent = ({ name, children }) => {
  return (
    <div>
      나의 새로운 {name}컴포넌트
      <div>{children}이건 children props입니다.</div>
    </div>
  );
};

MyComponent.defaultProps = {
  name: "기본이름",
};

MyComponent.propTypes = {
  name: propTypes.string,
};
export default MyComponent;
```

```jsx
import MyComponent from "./MyComponents";

const App = () => {
  return <MyComponent name={3}>children</MyComponent>;
};

export default App;
```

propTypes로 name에 문자열로 전달해야함을 지정하고, 부모컴포넌트가 숫자로 전달하게되면 콘솔창에서 이와같은 내용을 출력한다.  
<img src="https://user-images.githubusercontent.com/76278794/144861568-2085cf20-f638-48f4-9ff0-83c5683dd36c.png">
잘못된 타입의 props가 전달되었음을 개발자에게 알릴 수 있다.

#### 3.3.6.1 isRequired 사용해 필수 props를 지정하기

위에서 propTypes를 지정한 후, isRequired메서드를 사용하면 필수 props를 지정할 수 있다.  
isRequired가 필요한 이유는 props가 전달되어 컴포넌트에서 사용될때, props가 전달되지 않아도 아무런 경고창을 발생시키지 않아 오류가능성이 있기 때문이다.

```jsx
import React from "react";
import propTypes from "prop-types";

const MyComponent = ({ name, children, favoritenumber }) => {
  console.log(favoritenumber);
  return (
    <div>
      나의 새로운 {name}컴포넌트
      <div>{children}이건 children props입니다.</div>
      <div>{favoritenumber}</div>
    </div>
  );
};

MyComponent.defaultProps = {
  name: "기본이름",
};

MyComponent.propTypes = {
  name: propTypes.string,
};
export default MyComponent;
```

부모컴포넌트가 props로 favoritenumber를 전달하지 않은 상황에서 `터미널이나 개발자도구 콘솔창에 아무런 경고가 발생하지 않는다.`  
개발자가 이런 상황에 직면하면 어디서 오류가 난지 모르고, 한참을 헤매는데, isRequired를 사용하면

```js
---
MyComponent.propTypes = {
  name: propTypes.string,
  favoritenumber: propTypes.number.isRequired,
};
---
```

콘솔창에서 개발자에게 필수 propTypes가 잘못되었다는 것을 알려준다.
![스크린샷 2021-12-06 오후 11 26 21](https://user-images.githubusercontent.com/76278794/144863322-dba4b4e6-b929-4a7d-9338-4ebb6c070ed2.png)

#### 3.3.6.2 proptypes 종류

1. array : 배열
2. arrayOf(다른 propType) : 특정 propType으로 이루어진 배열을 의미. arrayof(propTypes.obj)은 객체로 이루어진 배열을 의미
3. bool : true or false
4. func : 함수
5. number : 숫자
6. object : 객체
7. string : 문자열
8. symbol : ES6에서 추가된 symbol타입, 특정 키값을 symbol로 선언하면 어떤 객체의 키값으로 symbol을 줄 수 있음. python의 dict에서 키값을 주는것과 같음. iterable하지 않아서 객체를 for문돌려도 키값은 제외하고 for문을 돌린다.
9. node : 렌더링가능한 모든 것
10. instanceOf(클래스) : 특정 클래스의 인스턴스
11. oneOf(['dog', 'cat']) : 주어진 배열 요소 중 하나
12. oneOfType([propTypes.string, propTypes.number]) : 주어진 배열 안의 종류 중 하나
13. objectOf(propTypes.number) : 객체의 모든 값이 특정 propType인 객체
14. shape({name : propTypes.string, num : propTypes.number}) : 객체의 특정 키의 값을 propTypes로 준 객체
15. exect({name : propTypes.string, num : propTypes.number}) : 객체의 특정 키의 값이 특정 propTypes가 아니어야함

참고
(npmjs package설명)[https://www.npmjs.com/package/prop-types]

### 3.3.7 클래스형 컴포넌트에서 props 사용하기

함수형 컴포넌트를 클래스형 컴포넌트로 바꾸면 다음과 같다.

```jsx
import React from "react";
import propTypes from "prop-types";
import { Component } from "react";

class MyComponent extends Component {
  render() {
    const { name, favoritenumber, children } = this.props;
    return (
      <div>
        hello, my name is {name}
        children value is {children}
        my favnumber is {favoritenumber}
      </div>
    );
  }
}

MyComponent.defaultProps = {
  name: "기본이름",
};

MyComponent.propTypes = {
  name: propTypes.string,
  favoritenumber: propTypes.number.isRequired,
};
export default MyComponent;
```

클래스형 컴포넌트 내부에서 defaulProps나 propTypes를 지정할수도 있다.

```jsx
import React from "react";
import propTypes from "prop-types";
import { Component } from "react";

class MyComponent extends Component {
  static defaultProps = {
    name: "기본이름",
  };
  static propTypes = {
    name: propTypes.string,
    favoritenumber: propTypes.number.isRequired,
  };

  render() {
    const { name, favoritenumber, children } = this.props;
    return (
      <div>
        hello, my name is {name}
        children value is {children}
        my favnumber is {favoritenumber}
      </div>
    );
  }
}

export default MyComponent;
```

## 3.4 state

리액트에서 state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미한다.  
props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값, 컴포넌트 자신은 전달받은 props를 읽기 전용으로만 사용할 수 있다.

이 props를 수정하기 위해서는 부모컴포넌트에서 바꿔주어야한다.

### 3.4.1 클래스형 컴포넌트에서 state

```jsx
import { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      number: 0,
    };
  }
  render() {
    const { number } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <button
          onClick={() => {
            this.setState({ number: number + 1 });
          }}
        >
          Click!
        </button>
      </div>
    );
  }
}
export default Counter;
```

js의 기본 문법상으로, `class Child extends Parent`는 부모클래스를 확장하는 문법이다.  
따라서 이 클래스형 컴포넌트는 `Component`라는 부모 클래스를 확장하는 `Counter`라는 클래스를 정의한다.

클래스형 컴포넌트에서 state를 설정할때, constructor메서드를 작성한다.  
이때, super(props)는 부모클래스의 생성자함수를 호출하는데, `Component`의 생성자함수를 호출한다.

#### 3.4.1.1 state객체 안에 여러 값이 있을 떄

```jsx
import { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      number: 0,
      fixedNumber: 0,
    };
  }
  render() {
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>바뀌는 값{number}</h1>
        <h2>바뀌지 않는 값{fixedNumber}</h2>
        <button
          onClick={() => {
            this.setState({ number: number + 1 });
          }}
        >
          Click!
        </button>
      </div>
    );
  }
}
export default Counter;
```

this.setState함수는 인자로 전달된 객체 안에 들어있는 값만 바꿔준다.

#### 3.4.1.2 state를 constructor에서 꺼내기

constructor메서드를 사용하지 않고 state를 정의할 수 있다.

```jsx
import { Component } from "react";

class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  };

  render() {
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>바뀌는 값{number}</h1>
        <h2>바뀌지 않는 값{fixedNumber}</h2>
        <button
          onClick={() => {
            this.setState({ number: number + 1 });
          }}
        >
          Click!
        </button>
      </div>
    );
  }
}
export default Counter;
```

#### 3.4.1.3 this.setState에 함수인자 전달하기

this.setState를 사용해 state값을 업데이트할때는 상태가 비동기적으로 업데이트된다.

비동기적으로 업데이트된다는 의미는 setState를 호출한다고해서 즉각적으로 바뀐 state로 렌더링되지 않는다는 것.

```jsx
import { Component } from "react";

class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  };

  render() {
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>바뀌는 값{number}</h1>
        <h2>바뀌지 않는 값{fixedNumber}</h2>
        <button
          onClick={() => {
            this.setState({ number: number + 2 });
            console.log("+2", number);
            this.setState({ number: number + 1 });
            console.log("+1", number);
          }}
        >
          Click!
        </button>
      </div>
    );
  }
}
export default Counter;
```

<img src="https://user-images.githubusercontent.com/76278794/144974071-0fdc3a57-9dc3-4c58-a5bf-14770d08369f.png">

`setState로 state를 변경했음에도 console.log로 state를 출력해보면 state에 아무런 변화가 생기지 않았음을 알 수 있다.`

리액트 공식문서에서는 react가 성능을 위해 여러 setState()호출을 단일 업데이트로 한꺼번에 처리할 수 있다고 명시했다.  
이걸 `비동기적`업데이트라고 한다.  
여러개의 setState호출을 이렇게 비동기적으로 업데이트하는 걸 `batching`이라고도하는데, onClick함수가 시작되고 종료된 시점이 batching의 단위이다.

이렇게 batching이 되면, 마지막에 호출된 setState만이 적용되는 것을 볼 수 있는데,

동일 이벤트 리스너에서 `setState 여러번 처리할 때, 동일한 state에 대해 setState를 실행하고 싶다면`,

해결책으로 책에서는 this.setState를 사용할때 객체 대신, 함수를 인수로 넣어준다고한다.  
함수를 인자로 넣을때, prevState를 매개변수로 넣어 이전 state를 바탕으로 setState가 연산되고, 새로운 state를 리턴하게된다.

```js
this.setState((prevState, props) => {
  return {
    업데이트내용,
  };
});
```

prevState는 기존상태, props는 현재 갖고있는 props를 의미, 업데이트 과정에서 props 필요없으면 생략가능

```jsx
import { Component } from "react";

class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  };

  render() {
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>바뀌는 값{number}</h1>
        <h2>바뀌지 않는 값{fixedNumber}</h2>
        <button
          onClick={() => {
            this.setState((prevState) => {
              return {
                number: prevState.number + 1,
              };
            });
            this.setState((prevState) => ({
              number: prevState.number + 1,
            }));
          }}
        >
          Click!
        </button>
      </div>
    );
  }
}
export default Counter;
```

1. onClick 이벤트 발생
2. react가 setState 감지, 업데이트 목록에 setState를 넣어둠
3. 각각의 setState가 이전 state를 기준으로 업데이트하므로 최종 state.number는 +2가된다.

#### 함수를 인자로 넣는 방법

```jsx
//1
this.setState({ number: this.state.number + 1 });
//-----------------
//2
this.setState((prevState) => {
  return {
    number: prevState.number + 1,
  };
});
```

#### 3.4.1.4 setState이후 특정작업 실행하기

setState의 첫번째 인자로 함수를 주었는데, setState로 값을 업데이트하고 특정 작업을 하고싶다면 setState의 두번째 인자로 콜백함수를 등록해 작업을 처리할 수 있다. (setState완료 후, 작업)

```jsx
<button
onClock={() => {
  this.setState({
    number : number + 1
  }, () => {console.log('setState호출')})
}}>
```

그런데, 문득 setState가 여러개 호출될때, 각각에 대해 후속작업이 명시되면 어떻게 될까가 궁금했다.

```jsx
<button
  onClick={() => {
    this.setState(
      (prevState) => {
        return {
          number: prevState.number + 2,
        };
      },
      () => {
        console.log(this.state);
      }
    );
    this.setState(
      (prevState) => ({
        number: prevState.number + 1,
      }),
      () => console.log(this.state)
    );
  }}
>
  Click!
</button>
```

<img src = "https://user-images.githubusercontent.com/76278794/144985621-ee625537-94ac-423a-9c4c-0657e0cfcd4f.png">
이렇게 setState가 종료된 이후의 값을 기준으로 console이 출력되는 것을 볼 수 있다.

그렇다면 만약 다른 state가 껴있다면?

```jsx
<button
  onClick={() => {
    this.setState(
      (prevState) => {
        return {
          number: prevState.number + 2,
        };
      },
      () => {
        console.log(this.state);
      }
    );
    this.setState(
      (prevState) => ({
        number: prevState.number + 1,
      }),
      () => console.log(this.state)
    );
    this.setState(
      {
        testnumber: testnumber + 1,
      },
      () => {
        console.log(this.state);
      }
    );
  }}
>
  Click!
</button>
```

<img src="https://user-images.githubusercontent.com/76278794/144986159-c8a58400-5118-47e5-9eb0-7dddc673f315.png">

역시 setState가 모두 종료된 이후, console이 출력되는 것을 볼 수 있다.

setState는 batching되어 state를 일괄적으로 업데이트하는데, 그 이후 console.log의 연산은 setState가 끝나고 순차적으로 실행된다.

```jsx
<button
  onClick={() => {
    this.setState(
      (prevState) => {
        return {
          number: prevState.number + 2,
        };
      },
      () => {
        console.log(this.state);
      }
    );
    this.setState(
      {
        testnumber: testnumber + 1,
      },
      () => {
        console.log(this.state.testnumber);
      }
    );
    this.setState(
      (prevState) => ({
        number: prevState.number + 1,
      }),
      () => console.log(this.state)
    );
  }}
>
  Click!
</button>
```

<img src="https://user-images.githubusercontent.com/76278794/144986585-fa8c4155-4d89-4e7f-a579-8d770137e759.png">

이렇게 순서가 바뀐 것을 볼 수 있다.

1. setState로 state에 대한 업데이트 실행
2. 이후 각 setState에 대한 콜백함수를 위에서부터 순차적으로 실행
   이 순서이다.

### 3.4.2 함수형 컴포넌트에서 useState 사용하기

함수형 컴포넌트에서는 useState라는 함수를 이용해 state를 사용한다.

```jsx
import React, { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("");
  const onClickEnter = () => setMessage("안녕하세요");
  const onClickLeave = () => setMessage("안녕하 가세요!");

  return (
    <div>
      <button onClick={onClickEnter}>입장</button>
      <button onClick={onClickLeave}>퇴장</button>
      <h1>{message}</h1>
    </div>
  );
};

export default Say;
```

useState함수의 인자에는 state의 초기값을 넣어줄 수 있는데, 클래스형 컴포넌트에서 state에 객체 형태를 넣어준것과 달리 useState의 인자에는 무엇이든 올 수 있다.  
이 useState함수를 호출하면 배열이 리턴되는데,  
첫 번째 원소로는 현재 상태,  
두 번째 원소로는 이 상태를 바꿔주는 함수가 리턴된다.  
이 상태를 바꿔주는 함수를 새터(setter)함수라고한다. 클래스형 컴포넌트의 setState()함수가 새터함수였다.

#### 3.4.2.3 한 컴포넌트에서 여러개의 useState 사용

```jsx
import React, { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("!");
  const onClickEnter = () => setMessage("안녕하세요");
  const onClickLeave = () => setMessage("안녕하 가세요!");
  const [color, setColor] = useState("black");

  return (
    <div>
      <button onClick={onClickEnter}>입장</button>
      <button onClick={onClickLeave}>퇴장</button>
      <h1 style={{ color }}>{message}</h1>

      <button
        style={{ color: "red" }}
        onClick={() => {
          setColor("red");
        }}
      >
        빨간색
      </button>
      <button
        style={{ color: "green" }}
        onClick={() => {
          setColor("green");
        }}
      >
        초록색
      </button>
      <button
        style={{ color: "blue" }}
        onClick={() => {
          setColor("blue");
        }}
      >
        파란색
      </button>
    </div>
  );
};

export default Say;
```

### 3.5 state를 사용할때 주의사항

state를 사용할때는 setState를 사용하거나 useState로 받은 세터함수를 사용해야한다.

그리고 state를 업데이트할때는 사본을 만들고, 사본에 값을 업데이트하고 사본을 세터함수로 업데이트한다.

객체에 대한 사본을 만들때는 `...`으로 사용하는 spread연산자를 사용하고, 배열에 대한 사본은 slice()같은 내장함수를 사용한다.

# 4. 리액트의 이벤트핸들링

## 4.1 리액트의 이벤트시스템

### 4.1.1 주의사항

1. 이벤트이름은 카멜표기법으로 작성해야한다
2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수형태의 값을 전달한다.
3. DOM요소에만 이벤트를 설정할 수 있다, 컴포넌트에는 이벤트리스너를 달아줄 수 없다.

## 4.2 예제로 이벤트핸들링 익히기

### 4.2.1 컴포넌트 생성 및 불러오기

```jsx
import React, { Component } from "react";

class EventPractice extends Component {
  render() {
    return (
      <div>
        <h1>이벤트연습</h1>
        <input
          type="text"
          name="message"
          placeholder="아무거나입력하세요"
          onChange={(e) => {
            console.log(e);
          }}
        ></input>
      </div>
    );
  }
}
export default EventPractice;
```

<img width="575" alt="스크린샷 2021-12-07 오후 7 03 27" src="https://user-images.githubusercontent.com/76278794/145008569-61c06113-8c11-47df-9780-763a26ea5581.png">

여기서 event 객체는 Syntheticevent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체.
SyntheticEvent는 이벤트가 끝나면 이벤트가 초기화되기때문에 정보를 참조할 수 없다.  
입력되는 각각의 값이 바로바로 사라지기때문에 onChange만 달아준다고 값을 변경할 수는 없다.
이 이벤트 객체를 참조할 일이 있다면, e.persist()함수를 호출해 값을 유지해야한다. 또는 state에 따로 값을 유지해야한다.

```jsx
import React, { Component } from "react";

class EventPractice extends Component {
  render() {
    return (
      <div>
        <h1>이벤트연습</h1>
        <input
          type="text"
          name="message"
          placeholder="아무거나입력하세요"
          onChange={(e) => {
            console.log(e.target.value);
          }}
        ></input>
      </div>
    );
  }
}
export default EventPractice;
```

input 안의 내용이 바뀔때마다 바뀐 값을 콘솔에서 출력한다.

#### 4.2.2.2 state에 input값 담기

```jsx
import React, { Component } from "react";

class EventPractice extends Component {
  state = {
    message: "",
  };
  render() {
    return (
      <div>
        <h1>이벤트연습</h1>
        <input
          type="text"
          name="message"
          placeholder="아무거나입력하세요"
          value={this.state.message}
          onChange={(e) => {
            this.setState({
              message: e.target.value,
            });
          }}
        ></input>
      </div>
    );
  }
}
export default EventPractice;
```

state에서 message state의 초기값을 설정,  
input에서 onChange이벤트가 일어나면, setState가 message state를 업데이트한다.  
input에서 변화가 생기면 setState함수가 state를 계속 갱신할 것이다.

#### 4.2.2.3 메시지창 띄우고 초기화

```jsx
<button
  onClick={() => {
    alert(this.state.message);
    this.setState({
      message: "",
    });
  }}
>
  확인
</button>
```

버튼이 클릭되면 onClick함수 호출, alert로 현재 state의 message를 창으로 띄우고, setState로 message를 초기화한다.

### 4.2.3 임의 메서드 만들기

리액트에서 이벤트 리스너를 달아줄때, 코드를 전달하기보다는 함수를 전달하라고 배웠다.  
가독성이 훨씬 좋다.

리팩토링

```jsx
import React, { Component } from "react";

class EventPractice extends Component {
  state = {
    message: "",
  };
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }

  handleChange(e) {
    this.setState({
      message: e.target.value,
    });
  }

  handleClick(e) {
    alert(this.state.message);
    this.setState({
      message: "",
    });
  }

  render() {
    return (
      <div>
        <h1>이벤트연습</h1>
        <input
          type="text"
          name="message"
          placeholder="아무거나입력하세요"
          value={this.state.message}
          onChange={this.handleChange}
        ></input>
        <button onClick={this.handleClick}>확인</button>
      </div>
    );
  }
}
export default EventPractice;
```

constructor함수를 보면 .bind(this)로 컴포넌트 자기자신과 함수를 바인딩하는 작업이 이루어지고있는데,  
클래스의 임의의 메서드가 이벤트로 등록되는 과정에서 this와의 관계가 끊어지므로, 메서드와 컴포넌트 this를 바인딩해주어야한다.  
bind()함수는 괄호 안 인자와 함수를 bind해서 새로운 객체를 리턴하는 함수이다.

#### 4.2.3.2 Property initialize Syntax

위에서 살펴본 메서드바인딩은 생성자 부분에서 하고 있다.  
새로운 메서드를 만들때마다 constructor에서 수정해주어야하기때문에 이를 더 간단하게 해주는 바벨의 transform-class-properties 문법이 있는데, 화살표 함수 형태로 메서드를 정의하면 바인딩 과정이 필요없다.

```jsx
handleChange = (e) => {
  this.setState({
    message: e.target.value,
  });
};

handleClick = (e) => {
  alert(this.state.message);
  this.setState({
    message: "",
  });
};
```

### 4.2.4. input 여러개 다루기

input이 여러개일때는 어떻게 다루어야할까?
쉽게 생각하면 input마다 새로운 메서드를 정의하고, 달아줄수도있는데, 더 쉽게 처리하기위해서는 이벤트 객체를 이용해야한다.

```jsx
<input
  type="text"
  name="username"
  placeholder="사용자명"
  value={this.state.username}
  onChange={this.handleChange}
></input>
```

이 태그는 value값을 state의 username으로 유지한다.  
onChange 이벤트가 발생하면 handleChange라는 함수가 실행되는데,

```jsx
handleChange = (e) => {
  this.setState({
    [e.target.name]: e.target.value,
  });
};
```

handleChange함수는 이벤트객체의 e.target.name을 키값으로 state를 변경한다.  
객체안에서 key값을 대괄호[]로 감싸면 그 안의 레퍼런스가 가리키는 값이 실제 키값으로 사용된다.  
따라서 위의 setState는 실제로 이렇게 작동한다.

```jsx
this.setState({
  username: e.target.value,
});
```

### 4.2.5 onKeyPress 이벤트 핸들링

name="message" 인 input에서 엔터가 눌리면 handleClick메서드를 호출하기위해서는

```jsx
<input
  type="text"
  name="message"
  placeholder="아무거나입력하세요"
  value={this.state.message}
  onChange={this.handleChange}
  onKeyPress={this.handleKeyPress}
></input>
```

이렇게 input태그에 onKeyPress 이벤트리스너를 달고, 함수를 호출하도록하고

```jsx
handleKeyPress = (e) => {
  if (e.key === "Enter") {
    this.handleClick();
  }
};
```

이벤트 객체의 key가 Enter면 handleClick함수를 호출하도록 하면된다.

## 4.3 함수형 컴포넌트로 교체

```jsx
import { useState } from "react";

const EventPractice = () => {
  const [message, setMessage] = useState("");
  const [username, setUsername] = useState("");

  const onChangeUsername = (e) => {
    setUsername(e.target.value);
  };

  const onChangeMessage = (e) => {
    setMessage(e.target.value);
  };

  const onClick = () => {
    alert(username + ":" + message);
    setMessage("");
    setUsername("");
  };

  const onKeyPress = (e) => {
    if (e.key === "Enter") {
      onClick();
    }
  };

  return (
    <div>
      <h1>이벤트연습</h1>
      <input
        type="text"
        name="username"
        placeholder="사용자명"
        value={username}
        onChange={onChangeUsername}
      ></input>
      <input
        type="text"
        name="message"
        placeholder="아무거나 입력하세요"
        value={message}
        onChange={onChangeMessage}
        onKeyPress={onKeyPress}
      ></input>
      <button onClick={onClick}>확인</button>
    </div>
  );
};
export default EventPractice;
```

클래스형 컴포넌트와 다른점은

1. useState로 state 선언을 해주었다는 것
2. 클래스형 컴포넌트에서 handleChange를 username과 message에 대한 함수로 분리

이 두가지가 있다.

input 태그가 2개밖에 없어서 분리된 함수도 2개밖에 안되지만, input이 여러개가 있다면?

이를 해결하기 위해선 useState에 객체를 넣는 방법이 있다.

```jsx
import { useState } from "react";

const EventPractice = () => {
  //객체로 useState의 초기값을 설정,
  //form에 초기 객체가 들어있음
  const [form, setForm] = useState({
    username: "",
    message: "",
  });

  const { username, message } = form; //비구조화할당,

  const onChange = (e) => {
    //spread연산자 ... 으로 form을 풀고,
    const nextForm = {
      ...form,
      //이벤트 객체로 키값에 접근해 원하는 값으로 덮어씌운다
      [e.target.name]: e.target.value,
    };
    setForm(nextForm);
  };

  const onClick = () => {
    alert(username + "::" + message);
    //세터함수
    setForm({
      username: "",
      message: "",
    });
  };

  const onKeyPress = (e) => {
    if (e.key === "Enter") {
      onClick();
    }
  };

  return (
    <div>
      <h1>이벤트연습</h1>
      <input
        type="text"
        name="username"
        placeholder="사용자명"
        value={username}
        onChange={onChange}
      ></input>
      <input
        type="text"
        name="message"
        placeholder="아무거나 입력하세요"
        value={message}
        onChange={onChange}
        onKeyPress={onKeyPress}
      ></input>
      <button onClick={onClick}>확인</button>
    </div>
  );
};
export default EventPractice;
```

useState의 초기값으로 username과 message를 키로하는 객체를 초기값으로 부여한다.

비구조화할당문법으로 form의 username과 message를 태그들이 접근할 수 있도록 변수선언해준다.

onChange함수는 이벤트객체 e를 인자로 받는데, 이 인자 e로 이벤트가 발생한 input의 name에 접근한다.

```jsx
const onChange = (e) => {
  //spread연산자 ... 으로 form을 풀고,
  const nextForm = {
    ...form,
    //이벤트 객체로 키값에 접근해 원하는 값으로 덮어씌운다
    [e.target.name]: e.target.value,
  };
  setForm(nextForm);
};
```

현재 state로 선언되어있는 form객체를 복사해와서 nextForm이라는 새로운 객체를 선언해 안에 spread연산자로 풀어준다(사본생성)  
그리고 변화가 생긴 input의 name을 키로하는 value를 수정해준다.  
수정이 완료되면 setForm으로 세터함수를 실행한다.

onClick이벤트함수는 실행되었을때, 경고창 alert 이후 setForm으로 초기화해준다.

```jsx
const onClick = () => {
  alert(username + "::" + message);
  //세터
  setForm({
    username: "",
    message: "",
  });
};
```

# 5. ref

리액트에서 DOM에 이름을 다는 방법.  
HTML에서는 태그에 고유한 id를 부여하지만, 리액트의 컴포넌트는 재사용가능한 객체이기때문에  
하나의 컴포넌트를 중복해서 호출하면 중복 id를 가진 DOM이 생성된다.

```
Ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공합니다.

일반적인 React의 데이터 플로우에서 props는 부모 컴포넌트가 자식과 상호작용할 수 있는 유일한 수단입니다. 자식을 수정하려면 새로운 props를 전달하여 자식을 다시 렌더링해야 합니다. 그러나, 일반적인 데이터 플로우에서 벗어나 직접적으로 자식을 수정해야 하는 경우도 가끔씩 있습니다. 수정할 자식은 React 컴포넌트의 인스턴스일 수도 있고, DOM 엘리먼트일 수도 있습니다. React는 두 경우 모두를 위한 해결책을 제공합니다.
```

## 5.1 ref를 사용하는 상황

`DOM을 직접적으로 건드려야할때`

```jsx
import React, { Component } from "react";
import "./ValidationSample.css";

class ValidationSample extends Component {
  state = {
    password: "",
    clicked: false,
    validated: false,
  };

  handleChange = (e) => {
    this.setState({
      password: e.target.value,
    });
  };
  handleButtonClick = (e) => {
    this.setState({
      clicked: true,
      validated: this.state.password === "0000",
    });
  };

  render() {
    return (
      <div>
        <input
          type="password"
          value={this.state.password}
          onChange={this.handleChange}
          className={
            this.state.clicked
              ? this.state.validated
                ? "success"
                : "failure"
              : ""
          }
        ></input>
        <button onClick={this.handleButtonClick}>검증하기</button>
      </div>
    );
  }
}
export default ValidationSample;
```

input 태그는 내용이 입력됨에따라 onChange함수로 state를 변경하면서 변경된 state로 value값을 유지한다.

button 태그에서 버튼이 클릭되면 setState를 통해 clicked state를 true로 변환하고, validated state는 input 태그에서 value값으로 가지고있는 password state에따라 true나 false가 리턴된다.

input 태그의 클래스를 부여할때 삼항 연산자가 2번쓰였는데, clicked가 false이면 빈 문자열을,  
true이면 현재 validated가 true인지 false인지에 따라 다른 클래스를 갖게한다.

### 5.1.3 DOM을 꼭 사용해야하는 상황에는 무엇이 있는가

특정 input에 포커스 주기
스크롤 박스 조작하기
Canvas 요소에 그림 그리기 등

이때 DOM에 직접 접근해야하는데, 이를 위해 ref를 사용한다.

## 5.2 ref 사용

ref를 사용하는 방법에는 2가지가 있다.

### 5.2.1 콜백함수를 통한 ref설정

ref를 달고자하는 요소에 ref라는 콜백 함수를 props로 전달해주면된다.  
이 콜백 함수는 ref값을 파라미터로 받고, 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해준다.

```jsx
<input
  ref={(ref) => {
    this.input = ref;
  }}
  type="password"
  value={this.state.password}
  onChange={this.handleChange}
  className={
    this.state.clicked ? (this.state.validated ? "success" : "failure") : ""
  }
></input>
```

이제 이 컴포넌트에서 this.input은 input요소의 DOM을 가리킨다.

```jsx
handleButtonClick = (e) => {
  this.setState({
    clicked: true,
    validated: this.state.password === "0000",
  });
  console.log(this.input);
};
```

검증하기 버튼의 이벤트리스너 콜백함수에 `console.log(this.input)`을 하면  
<img width="635" alt="스크린샷 2021-12-08 오후 6 48 10" src="https://user-images.githubusercontent.com/76278794/145186637-4949031b-8708-4a81-9366-5e8698e8e877.png">

이렇게 DOM객체를 리턴한다

### 5.2.2 createRef를 통한 ref설정

16.3 버전부터 내장함수 createRef를 통해 만들 수 있게 되었다.

```jsx
import React, { Component } from "react";

class RefSample extends Component {
  input = React.createRef();
  handleFocus = () => {
    this.input.current.focus();
  };
  handleOnClick = () => {
    console.log(this.input.current);
  };

  render() {
    return (
      <div>
        <input ref={this.input}></input>
        <button onClick={this.handleOnClick}>inputdom확인</button>
      </div>
    );
  }
}

export default RefSample;
```

컴포넌트 내부에서 멤버변수로 React.createRef()함수를 담아주었다.  
긜고 이 멤버변수를 ref를 달고자하는 엘리먼트에 props로 전달한다.

나중에 ref를 설정해준 DOM에 접근하기 위해서는 `this.input.current`를 조회한다.  
그냥 this.input으로 접근하면, current를 키값으로하는 객체가 리턴되기 때문이다.

### 5.2.3 적용

현재 ValidationSample 컴포넌트에서 검증하기 버튼을 누르면 input 요소의 텍스트 커서가 버튼으로 넘어가서 안보인다.  
비밀번호가 틀릴때마다 다시 password input을 마우스로 눌러서 입력해야하는 불편함이 존재한다.  
비밀번호가 틀렸을때, 다시 password를 입력할 수 있도록 포커스를 조정하도록하자.

#### 5.2.3.1 input에 ref달기

ValidationSample의 input요소에 ref를 달자.

```jsx
<input
  ref={(ref) => {
    this.input = ref;
  }}
  type="password"
  value={this.state.password}
  onChange={this.handleChange}
  className={
    this.state.clicked ? (this.state.validated ? "success" : "failure") : ""
  }
></input>
```

그리고 검증하기 버튼이 클릭되면 focus가 input태그로 가도록하자.  
이 input태그의 DOM은 this.input으로 접근할 수 있다.

```jsx
handleButtonClick = (e) => {
  this.setState({
    clicked: true,
    validated: this.state.password === "0000",
  });
  this.input.focus();
};
```

## 5.3 컴포넌트에 ref 달기

리액트에서는 컴포넌트에도 ref를 달 수 있다.  
이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 쓴다.  
DOM에 ref를 다는 방법과 같다.

### 5.3.1 사용법

```jsx
<MyComponent
  ref={(ref) => {
    this.myComponent = ref;
  }}
/>
```

이렇게 설정하면 컴포넌트 내부의 메서드와 멤버 변수에도 접근할 수 있다.

### 5.3.2 컴포넌트 초기설정

```jsx
import React, { Component } from "react";

class ScrollBox extends Component {
  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative",
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)",
    };

    return (
      <div
        style={style}
        ref={(ref) => {
          this.box = ref;
        }}
      >
        <div style={innerStyle} />
      </div>
    );
  }
}
export default ScrollBox;
```

### 5.3.3 컴포넌트에 메서드 생성

```jsx
scrollToBottom = () => {
  const { scrollHeight, clientHeight } = this.box;
  this.box.scrollTop = scrollHeight - clientHeight;
};
```

바깥 div 안에 gradient가 먹여져있는 650px높이의 div가 있다.  
이 div를 this.box ref를 가진 div가 감싸고있는데,  
이 DOM은 scrollTop, scrollHeight, clientHeight와 같은 값을 가진다.

scrollTop : 세로 스크롤바의 위치  
scrollHeight : 스크롤이 있는 박스안의 div높이,(안쪽 div, 650px)  
clientHeight : 스크롤이 있는 박스(바깥 div)의 높이(300px)

스크롤이 내려갈때마다 overflow된 내용이 바깥 div안쪽으로 들어와 표현된다.

스크롤이 0일때 안쪽 div의 최상단에 위치한다.

따라서 맨 아래로 스크롤을 내리기 위해서는 스크롤이 `overflow되어 안보이는 만큼` 내려와야한다.

### 5.3.4 컴포넌트에 ref달고 내부 메서드 사용

```jsx
import ScrollBox from "./ScrollBox";
import React, { Component } from "react";

class App extends Component {
  render() {
    return (
      <div>
        <ScrollBox ref={(ref) => (this.ScrollBox = ref)} />
        <button onClick={() => this.ScrollBox.scrollToBottom()}>
          맨 밑으로
        </button>
      </div>
    );
  }
}

export default App;
```

ScrollBox 컴포넌트에 ref로 this.ScrollBox를 달아주었다.  
이제 App컴포넌트에서 this.ScrollBox를 접근할 수 있는데,  
ScrollBox컴포넌트에서 갖고있는 scrollToBottom메서드를 onClick 속성으로 가지는 button을 만들면 된다.

# 6. 컴포넌트 반복

화면에 반복적인 요소를 그릴때, 각 요소를 그려야하면 비효율적이다.  
반복되는 내용을 컴포넌트로 만들어 map함수를 적용하자.

## 6.1 자바스크립트의 map()함수

JS 배열객체에 map함수를 적용하여 반복되는 컴포넌트를 렌더링할 수 있다.

### 6.1.1 문법

`array.map(callback, [thisArg])`
`callback` => 새로운 배열의 요소를 생성하는 `콜백함수`, 파라미터는

- currentValue : 현재 처리하고 있는 요소
- index : 현재 처리하고 있는 요소의 index값
- array : 현재 처리하고 있는 원본배열

`this.arg` => callback함수 내부에서 사용할 this 레퍼런스, 선택사항

### 6.1.2 예제

```js
var numbers = [1, 2, 3, 4, 5];

var processed = numbers.map(function (num) {
  return num * num;
});
console.log(processed);
// VM7025:1 (5) [1, 4, 9, 16, 25]

var idex = numbers.map(function (num, index) {
  return index * index;
});
console.log(idex);
// VM7283:1 (5) [0, 1, 4, 9, 16]
```

## 6.2 데이터배열을 컴포넌트 배열로 변환

```jsx
import React from "react";

const IterationSample = () => {
  const names = ["눈", "크리스마스", "얼음"];
  const nameList = names.map((name) => <li>{name}</li>);

  return <ul>{nameList}</ul>;
};

export default IterationSample;
```

names의 각 요소가 nameList에 li태그로 감싸져 JSX코드로 담겨져있다.

### 6.2.2 key prop

```
index.js:1 Warning: Each child in a list should have a unique "key" prop.

Check the render method of `IterationSample`. See https://reactjs.org/link/warning-keys for more information.
    at li
    at IterationSample
    at div
    at App (http://localhost:3000/static/js/main.chunk.js:47:1)
```

위 코드를 그대로 렌더링하면 key prop이 없다는 경고 메세지가 표시된다.

## 6.3 key

리액트가 key를 필요로하는 이유는 컴포넌트 배열을 렌더링할때 어떤 원소가 변동이 되었는지 빠르게 찾아내기 위해 사용한다.

```html
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

이전 Virtual DOM과 비교해, 사람이 보기에는 맨 앞에 li가 하나만 추가되었음에도  
리액트는 이를 모두 바뀐것으로 인지하고 다시 렌더링한다 -> 비효율발생

따라서 key를 부여함으로서 더 효율적인 렌더링이 가능하다

### 6.3.1 key설정

key를 설정할때는 prop설정하듯 해야한다.  
이 키값은 전역공간이 아닌 `형제사이`에서만 유일하면된다(li끼리만 안겹치면됨)

이 key값으로는 보통 id와같은 고유번호를 부여하는게 좋은데, 마땅한게 없다몀ㄴ index값을 사용하면된다.

index를 key로사용할때 주의할점은 `배열이 변경되면 효율적 리렌더링이 불가능하다`는 것이다.

## 6.4 응용

초기상태 -> 데이터 추가기능 -> 데이터 제거기능

### 6.4.1 초기상태설정

useState()으로 IterationSample변경

```jsx
import React, { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    { id: 1, text: "눈사람" },
    { id: 2, text: "얼음" },
    { id: 3, text: "눈" },
    { id: 4, text: "바람" },
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5);

  const nameList = names.map((name) => <li key={name.id}>{name.text}</li>);
  return <ul>{nameList}</ul>;
};

export default IterationSample;
```

### 6.4.2 데이터 추가기능

```jsx
import React, { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    { id: 1, text: "눈사람" },
    { id: 2, text: "얼음" },
    { id: 3, text: "눈" },
    { id: 4, text: "바람" },
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5);
  const onChange = (e) => {
    setInputText(e.target.value);
  };

  const onClickButton = () => {
    const nextNames = names.concat({
      id: nextId,
      text: inputText,
    });
    setNextId(nextId + 1);
    setNames(nextNames);
    setInputText("");
  };

  const nameList = names.map((name) => <li key={name.id}>{name.text}</li>);
  return (
    <>
      <input type="text" value={inputText} onChange={onChange}></input>
      <button onClick={onClickButton}>확인</button>
      <ul>{nameList}</ul>
    </>
  );
};

export default IterationSample;
```

Input과 확인 Button렌더링,

onChange -> Input의 text state를 유지
onClickButton -> 눌리면 현재 text state에 들어있는 내용을 nextID를 가진채로 추가.

concat함수로 불변성을 유지한다.(원본유지)

### 6.4.3 데이터 제거기능

데이터를 추가할때 불변성을 유지하기 위해 concat함수를 이용했었다.  
제거할때 불변성을 유지하기위해선 filter함수를 사용해야한다.

`arr.filter(원소 => 표현식)`
각 원소에 대해 표현식을 만족하는 원소로 배열을 새로 만들어 리턴한다.

```js
numbers = [1, 2, 3, 4, 5];
const biggerthanthree = numbers.filter((number) => number > 3);
const withoutthree = numbers.filter((number) => number != 3);
```

```jsx
const nameList = names.map((name) => (
    <li key={name.id} onDoubleClick={() => onRemove(name.id)}>
      {name.text}
    </li>
```

key값으로 id가 li에 부여되고있는데, 해당 id를 가진 태그가 더블클릭되면 그 id를 인자로 받는 onRemove함수를 호출한다.

```jsx
const onRemove = (id) => {
  const nextNames = names.filter((name) => name.id !== id);
  setNames(nextNames);
};
```

onRemove함수는 names state에 대해 인자로받은 id를 제외한 리스트를 새로 생성하고,  
state를 업데이트한다.

# 7. 라이프사이클 메서드

컴포넌트의 수명주기는 렌더링 되기전에서 시작해 페이지에서 사라질때 끝난다.  
컴포넌트를 업데이트하기 전후로, 혹은 렌더링할때 작업을 처리해야할수도 있고, 불필요한 없데이트를 방지해야할때도 있다.  
이때 라이프사이클 메서드를 사용한다.  
이 라이프사이클 메서드는 클래스형 컴포넌트에서만 사용한다. 함수형 컴포넌트에서는 Hooks를 사용해야한다.

## 7.1 라이프사이클 메서드 이해

will이 붙은 메서드는 특정 작업 이전, did가 붙은 메서드는 특정 작업 이후에 실행되는 메서드이다.
컴포넌트 클래스에서 덮어 씌워 사용한다.  
크게 3 카테고리로 나뉜다.

### 마운트

마운트 : DOM이 생성되고 웹 브라우저상에 나타남

1. 컴포넌트 생성
2. constructor : 생성자
3. getDerivedStateFromProps : props에 있는 값을 state에 넣을때
4. render : 렌더링할때 사용하는 메서드
5. componentDidMount : 컴포넌트가 웹 브라우저상에서 나타난 후 호출하는 메서드

### 업데이트

업데이트 해야하는 경우

- 부모 컴포넌트가 넘겨주는 props 변경
- 자신의 state 변경
- 부모 컴포넌트의 리렌더링
- forceUpdate로 강제로 렌더링

업데이트될때

1. 위 요인에 따라 getDerivedStateFromProps
2. shouldComponentUpdate : 현재 state,props와 새로설정될 state,props를 비교가능
3. render : 컴포넌트의 리렌더링할때 사용하는 메서드
4. getSnapshotBeforeUpdate : 컴포넌트의 변화를 DOM에 반영하기 바로 직전에 호출
5. 위 작업이 끝나면 웹 브라우저 상에 실제 DOM변화가 일어난다.
6. componentDidUpdate : 컴포넌트의 업데이트 작업이 끝난 직후 호출

### 언마운트

컴포넌트를 DOM에서 제거하는 것을 언마운트라고 부른다.

1. componentWillUnmount : 컴포넌트가 브라우저 상에서 사라지기 전에 호출하는 메서드

## 7.2 종류

### 7.2.1 render

컴포넌트의 모양새를 정의한다.  
이 메서드 안에서 this.state, this.props에 접근하고, 리액트 요소를 return한다.

!주의!  
`이 메서드 안에서는 이벤트 설정이 아닌 곳에서는 setState를 사용해선 안되고, 브라우저의 DOM에 접근해서도 안된다.`  
이벤트 설정이 아닌 곳에서 state를 변경하거나 DOM에 접근하기 위해서는 componentDidMount라는 메서드에서 처리해야한다.

### 7.2.2 constructor

컴포넌트의 생성자 메서드, 새 컴포넌트를 만들때 처음으로 실행된다.  
초기 state를 설정한다.

### 7.2.3 getDerivedStateFromProps

props로 받아온 값을 state와 동기화시킬때 사용된다.  
따라서 마운트와 업데이트할때 호출된다.

```js
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.value !== prevState.value) { //조건에 따라 값 동기화
    return { value : nextProps.value}
  }
  return null //바꿀 필요가 없다면 null
}
```

### 7.2.4 componentDidMount

```js
componentDidMount() {...}
```

컴포넌트의 마운트가 완료되고나서, 즉 컴포넌트의 첫 렌더링이 완료된 시점에서 실행된다.  
다른 라이브러리나 프레임워크의 함수를 호출하거나 이벤트 등록, setTimeout, setInterval, 네트워크 요청과 같은  
`비동기 작업`을 처리하면 된다.

### 7.2.5 shouldComponentUpdate

```js
shouldComponentUpdate(nextProps, nextState) {...}
```

props나 state가 변경되었을때, 리렌더링 여부를 결정하는 메서드이다.

인자로 들어온 nextProps와 nextState가 새로 설정될 props와 state이며,  
이를 현재 state와 props, this.state와 this.props로 비교한다.

이 메서드는 true나 false를 리턴해 이에따라 리렌더링을 실시한다.  
따로 설정하지 않는다면 기본값으로 true가 리턴된다.

프로젝트의 성능을 최적화할때, 리렌더링을 방지함으로써 불필요한 렌더링을 막을 수 있다.

### 7.2.6 getSnapshotBeforeUpdate

```js
getSnapshotBeforeUpdate(prevProps, prevState) {
  if (prevState.array !== this.state.array) {
    const { scrollTop, scrollHeight} = this.list
    return { scrollTop, scrollHeight}
  }
}
```

render에서 만들어진 결과물이 브라우저에 실제로 반영되기 전에 호출된다. (실제 브라우저의 DOM의 변화가 생기기 전)
여기서의 리턴값은 componentDidUpdate에서 파라미터로 활용된다
업데이트하기 직전의 값을 참고할 일이 있을때 활용한다.(스크롤바의 위치같은..)

### 7.2.7 componentDidUpdate

```js
componentDidUpdate(prevProps, prevState, snapshot){...}
```

리렌더링을 완료한 후 실행, 업데이트가 끝난 시점에 실행된다.  
DOM관련 처리를 해도 무방하며, prevProps나 prevState같이 이전 데이터에 접근할 수 있다.  
또한 위의 getSnapshotBeforeUpdate에서 리턴값을 3번째 인자 snapshot으로 전달받는다.

### 7.2.8 componentWillUnmount

컴포넌트를 DOM에서 제거할때 실행. componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM 등을 여기서 제거한다.

### 7.2.9 componentDidCatch

컴포넌트 렌더링 도중에 에러발생 시, 오류 UI를 보여 줄 수 있게 해준다.

```js
componentDidCatch(error, info) {
  this.setState({
    error: true
  });
  console.log({error, info
})
}
```

이 메서드는 자신에게 발생하는 에러가 아닌, `this.props.children`으로 전달되는 컴포넌트에서 발생하는 에러를 잡아낸다.  
`error`는 파라미터에 어떤 에러가 발생했는지 알려주고, `info` 파라미터는 어디 있는 코드에서 오류가 발생했는지 알려준다.

## 7.3 사용

```jsx
import React, { Component } from "react";
import LifeCycleSample from "./LifeCycleSample";

function getRandomColor() {
  return "#" + Math.floor(Math.random() * 16777215).toString(16);
}

class App extends Component {
  state = {
    color: "#000000",
  };

  handleClick = () => {
    this.setState({
      color: getRandomColor(),
    });
  };
  render() {
    console.log("App컴포넌트 렌더링");
    return (
      <div>
        <button onClick={this.handleClick}>랜덤색상</button>
        <LifeCycleSample color={this.state.color}></LifeCycleSample>
      </div>
    );
  }
}

export default App;
```

App컴포넌트가 자식컴포넌트에게 color state를 props로 전달한다.  
버튼이 클릭되면 color state가 변경된다.\*\*\*\*

```jsx
import React, { Component } from "react";

class LifeCycleSample extends Component {
  state = {
    //초기 state
    number: 0,
    color: null,
  };

  myRef = null; //Ref설정부분

  constructor(props) {
    //생성자
    super(props);
    console.log("contructor");
  }

  //부모컴포넌트로부터 전달받은 props를 state와 동기화시킨다.
  static getDerivedStateFromProps(nextProps, prevState) {
    console.log("getDerivedStateFromProps");
    if (nextProps.color !== prevState.color) {
      return { color: nextProps.color };
    }
    return null;
  }

  //컴포넌트의 첫 렌더링이 완료
  componentDidMount() {
    console.log("componentDidMount");
  }

  //update를 인식하면 nextprops와 nextstate를 인자로 갖는다.
  //
  shouldComponentUpdate(nextProps, nextState) {
    console.log("shouldComponentUpdate", nextProps, nextState);
    // 숫자의 마지막 자리가 4면 리렌더링하지 않는다.
    return nextState.number % 10 !== 4;
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  handleClick = () => {
    this.setState({
      number: this.state.number + 1,
    });
  };

  //update이후, 이전 props와 이전 state에 대한 정보를 componentDidUpdate에서 snapshot 파라미터로 전달한다.
  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log("getSnapshotBeforeUpdate");
    if (prevProps.color !== this.state.color) {
      return this.myRef.style.color;
    }
    return null;
  }

  //snapshot 파라미터는 getSnapshotBeforeUpdate 메서드에서 리턴된 파라미터.
  //리턴된 파라미터가 있다면 이전  색상 속성을 조회
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log("componentDidUpdate", prevProps, prevState);
    if (snapshot) {
      console.log("snapshot, 업데이트 이전 색", snapshot);
    }
  }

  render() {
    const style = {
      color: this.props.color,
    };
    console.log("LifeCycleSample Rendered");
    return (
      <div>
        <h1 style={style} ref={(ref) => (this.myRef = ref)}>
          {this.state.number}
        </h1>
        <p>color : {this.state.color}</p>
        <button onClick={this.handleClick}>더하기</button>
      </div>
    );
  }
}
export default LifeCycleSample;
```

### 7.3.1 초기렌더링

1. App 컴포넌트 렌더링
2. LifeCycleSample 컴포넌트 호출
3. LifeCycleSample 생성자 호출
4. getDerivedStatefromProps 호출, 부모컴포넌트가 전달하고있는 color props를 자식컴포넌트의 state와 동기화
5. 자식 컴포넌트 렌더링
6. 첫 렌더링 마친 이후 componentDidMount 호출

### 7.3.2 업데이트(색상)

업데이트는 첫 렌더링 끝난 이후 인식한다.

1. 부모컴포넌트에서 button 클릭 => state변화인식 => 업데이트인식 => 부모컴포넌트 다시 렌더링 => 자식컴포넌트도 리렌더링
2. 변경된 color가 자식컴포넌트에게 props로 전달
3. 자식컴포넌트에게로 전달되는 props도 같이 변화한다.
4. 자식컴포넌트에서 getDerivedStateFromProps 호출, 전달된 props가 nextProps, prevState는 업데이트 이전상태의 자식컴포넌트의 state
5. shouldComponentUpdate 호출, nextProps에 전달된 props, nextState에 업데이트될 state가 온다.
6. 렌더링함수 호출
7. getSnapshotBeforeUpdate 호출, 렌더링 이후 이전 props와 현재 바뀐 state의 색이 다르면 ref로 달린 태그의 style을 리턴한다.(snpshot)
8. 이 시점에서 실제 웹브라우저 DOM에 변화가 생긴다.
9. componentDidUpdate 호출, prevProps나 prevState를 인자로 가지고, snapshot파라미터도 가지고 있어서 업데이트 이전의 값으로 작업이 가능함.

### 7.3.3 업데이트(숫자)

1. number state는 color와는 다르게 자식 컴포넌트에서만 유지되고 있다.
2. 더하기 버튼 클릭 => 자식컴포넌트가 state변화 인식 => 업데이트 인식
3. getDerivedStateFromProps는 color변화가 감지되지않아 null이 리턴(props로 인해 바뀐 state가 없음)
4. shouldComponentUpdate는 바뀐 state의 1의자리 숫자가 4만 아니면 리렌더링한다. 4라면 여기서 업데이트종료, 리렌더링호출 x
5. 리렌더링(4가 아닐때)
6. getSnapshotBeforeUpdate, 색 그대로이므로 null 리턴
7. componentDidUpdate 호출

### 7.3.4 오류잡아내기

```jsx
<div>
  {this.props.missing.value}
  <h1 style={style} ref={(ref) => (this.myRef = ref)}>
    {this.state.number}
  </h1>
  <p>color : {this.state.color}</p>
  <button onClick={this.handleClick}>더하기</button>
</div>
```

오류가 났을때, 에러를 캐치하는 과정

Error를 잡기 위해선 `componentDidCatch`사용해야한다.

```jsx
import React, { Component } from "react";

class ErrorBoundary extends Component {
  state = {
    error: false,
  };

  componentDidCatch(error, info) {
    this.setState({
      error: true,
    });
    console.log("error");
  }
  render() {
    if (this.state.error) return <div>에러발생</div>;
    return this.props.children;
  }
}
export default ErrorBoundary;
```

에러가 발생하면 렌더링할 컴포넌트를 정의

```jsx
<ErrorBoundary>
  <LifeCycleSample color={this.state.color}></LifeCycleSample>
</ErrorBoundary>
```

상위 컴포넌트에서 감싸준다.
