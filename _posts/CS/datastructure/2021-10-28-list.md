---
title:  "[Datastructure] 한방향 연결리스트"
excerpt: "파이썬 자료구조"

categories:
  - datastructurepy
tags:
  - [computer science, data structure, python, singly linked list]

toc: true
toc_sticky: true
 
date: 2021-10-28
last_modified_at: 2021-10-28
---


```
class Node:
    def __init__(self, key = None):
        self.key = key
        self.next = None

    def __str__(self):
        return str(self.key)

class SinglyLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0

    def __len__(self):
        return self.size


    def pushFront(self, key): # 2 -> 1 2
        new_node = Node(key) # new_node = Node(1)
        new_node.next = self.head # new_node.next = Node(2)
        self.head = new_node # self.head = Node(1)
        self.size += 1
```
# 연결리스트란

연결리스트는 파이썬의 리스트와는 다르게 key값과 link값으로 이루어져있다.  

리스트는 각 인덱스가 메모리가 할당되어 각 원소의 주소값을 가지게된다. 그래서 상수시간 O(1) 내에 연산이 가능하다.  
<br>
하지만 연결리스트는 각 메모리가 원소의 주소(key값) + 다음값이 저장된 주소(link값) 이 저장되어 있다.   
key값과 link값이 함께 저장되어 있는 것을 Node라고 부른다.  
<br>

```python
class Node:
    def __init__(self, key = None): 
        self.key = key #노드의 키값
        self.next = None #노드의 링크값, 별도로 설정하지 않는다면 초기값은 none

    def __str__(self):
        return str(self.key) #키값 호출 시, print(self.key) 대신에 print(self) 로 바로 키값출력이 가능하도록 하는 메서드
```

## 특징

### 단점
연결리스트는 배열처럼 인덱스로 접근이 불가능하다.  
따라서 우리가 만약에 연결리스트의 3번 인덱스 값을 찾고싶다면, head노드(노드의 맨 첫번째 값)의 링크부터 따라서 들어가야하므로
head->1->2->3으로 총 3번의 계산이 필요하다.  
만약 100번 인덱스 값을 찾고 싶다면, 100번의 계산이 필요하므로 연결리스트의 시간복잡도는 O(N)이 된다.  

### 장점
연결리스트의 장점도 있다.  
일반적인 리스트가 insert를 하게되면 새로운 값을 맨 앞에 넣는다는 가정하에, 뒤의 모든 값을 밀어내야하므로 시간복잡도는 O(N)인데 반해,  
연결리스트는 head node를 새로 만들어 link값을 이전 head node의 주소를 가리키면 되므로 시간 복잡도는 O(1)이다.  

# 한방향 연결리스트

1. 노드들이 self.next 링크를 따라 한방향으로 연결된 리스트이다.  
2. 맨 앞의 노드를 head.node라 하고, head node를 알면 그 뒤의 모든 노드들을 찾을 수 있기때문에 연결리스트를 대표하는 노드이다.
3. 맨 마지막 노드는 self.next가 none을 저장한다.

```python
class SinglyLinkedList:
    def __init__(self): #리스트 생성시 자동호출메서드
        self.head = None #초기 head값은 none
        self.size = 0 #리스트의 노드의 개수

    def __iter__(self): #이터레이터 호출시 자동호출함수
        v = self.head #v에 head node 키값설정
        while v != None: #head node가 none이 아닐때(빈 리스트가 아닐때)
            yield v
            v = v.next

    def __str__(self): #str호출시 자동호출함수
        return "->".join(str(v) for v in self) #인스턴스 내의 

    def __len__(self):
        return self.size #인스턴스의 노드개수 리턴
```


## 지원연산

### pushfront

1. 현재 head node 앞에 새로운 node을 삽입해야하므로, 새로운 노드가 head node가 된다.
2. 새로운 node의 next값은 이전의 head node가 된다.
3. 연결리스트의 전체 사이즈가 1 커진다. 

```python
def pushfront(self, key):
    new_node = Node(key) #key값 가진 새로운 노드 생성
    new_node.next = self.head #새로운 노드의 next는 원래 head값인 self.head임
    self.head = new_node #self.head 는 새로운 노등니 new_node가 된다.
    self.size += 1
```

### pushback
1. 빈 리스트에 pushback은 새로운 노드는 head node가 된다.
2. .next가 none인 노드가 tail node가 된다. tail node 다음 값으로 주어진 node를 생성해 넣어야한다.
3. 이를 찾기 위해서는 head node로 먼저 접근해 .next가 none인 노드를 찾는 과정이 필요하다. 

```python
def pushback(self, key):
    new_node = Node(key)
    if self.size == 0: #현재 연결리스트가 비어있는 경우
        self.head = new_node #연결리스트의 head node는 new_node가 된다.
    
    else:
        tail = self.head #tail node찾기 위해 tail에 self.head를 지정
        while tail.next != None: #tail.next 가 none이 아니라면
            tail = tail.next #tail에 tail.next(self.head.next)를 지정하고 다시 while문 반복
        tail.next = new_node #while문 끝나면 tail에 연결리스트의 마지막값이 들어와있으므로 다음값에 새로운 노드 new_node 연결
    self.size += 1
```






