---
title: "[Database] 14 쿼리 최적화"
excerpt: "데이터베이스"

categories:
  - database
tags:
 - Quary Optimization


toc: true
toc_sticky: true

date: 2022-12-06
last_modified_at: 2022-12-06
---


# 쿼리 최적화


- 쿼리 최적화는 여전히 연구되고 있다.
- AI로 언어를 파싱해 어떻게 최적화를 할 것인가에 대한 연구가 여전히 진행되고 있다.
- 기초를 공부해 어떻게 최적화되는 지에 대해 알아보자.


<br><br>

# 쿼리 파싱

<img src="https://user-images.githubusercontent.com/76278794/206000520-c6a05ca6-a152-462a-8860-ddd612aaf4fe.png">

1. SQL 쿼리가 입력된다.
2. `Quary parser`에 전달된다.
	- 파서는 이를 AST(추상구문트리)로 변환한다.
3. `Query Rewrite`에 전달된다.
	- 재작성기에서는 정규형식으로 쿼리를 변환한다.
4. `Query Optimizer`에 전달된다.
	- 추상구문트리를 효율적인 계획으로 변환한다.
	- Plan generator와 Cost Estimator로 구성되어있다.
	- Cost Estimator는 시스템 카탈로그에서 다른 테이블에 대한 스키마를 가져와 쿼리 계획을 어떻게 짜는 것이 효율적인가에 대해 파악한다.
5. `Query Executor`
	- 효율적으로 생성된 쿼리에 대해 실행한다.


<br>

## Query parser

- 권한 확인
	- 쿼리 파서에 전달되는 쿼리는 사용자의 권한을 체크하고, 쿼리를 수행할 권한이 있는 사용자인지 확인하는 절차를 가진다.
- Parse tree 생성
	- AST(추상구문트리)를 생성한다.


<br>

## Query rewriter


- 추상구문트리를 캐노니컬 폼으로 변환한다.
- 뷰를 가져와서 다른 테이블에 조인하는 쿼리를 4개의 테이블 쿼리로 평면화해 일부 경우에 뷰를 참조한다.
- 일부 쿼리를 join으로 변환할 수 있기에, subquery들을 더 적은 수의 쿼리 블록으로 변환한다.


<br>

## Query Optimizer

- 비용을 기반으로한다.
	- 한 번에 1개의 쿼리블록만 계산한다.
	- 이때, 쿼리 블록이란 아래의 묶음이다.
		1. Select, Project, Join
		2. Group by / Aggregate FNC
		3. Order By

- 시스템 카탈로그에서 쿼리블록마다 최소비용으로 찾는 통계를 사용한다.
- 항상 올바르게 최적화하는 것은 아니다.


<br>

- 쿼리블록들은 관계대수로 변환된다.
- 아래와 같은 쿼리가 있다고 가정하자.
<img width="532" alt="스크린샷 2022-12-07 15 29 31" src="https://user-images.githubusercontent.com/76278794/206105266-bbc6b2d0-b2d2-4a28-92c6-47e204f5e2a6.png">

<br>

- 위 쿼리 블록은 아래와 같은 관계대수로 변환되며,
<img width="460" alt="스크린샷 2022-12-07 15 29 40" src="https://user-images.githubusercontent.com/76278794/206105287-7f64ca74-5768-4974-af99-584fd627eb3f.png">

- 관계대수는 아래와 같은 트리형태로 다시 변환된다.
<img width="335" alt="스크린샷 2022-12-07 15 29 46" src="https://user-images.githubusercontent.com/76278794/206105303-1a09b576-465d-4c14-a5e6-f870f5b42f22.png">












