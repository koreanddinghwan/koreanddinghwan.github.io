var store = [{
        "title": "첫 블로그 글",
        "excerpt":"첫 글 여기에는 mmistakes의 collection layout을 이용해 개인적인 블로그 글을 작성해보고자 한다. mmistakes의 collection 기능은 폴더 내에 _foldername인 폴더의 글들을 읽어올 수 있는데, _pages에서 collection할 폴더를 blablablabla….. 어제 밤새도록 작업했는데 생각해보니 이상한 곳에서 코드를 잘못 작성해서 계속 삑사리가 났었다.. 휴학 나는 어렸을때부터 글을 정~~~말 못 썼다. 아마 지금 고등학생들이랑 글쓰기...","categories": [],
        "tags": [],
        "url": "/mylogs/2021-11-07-first/",
        "teaser": "/assets/mylog/first-1.jpeg"
      },{
        "title": "[Frontend] 인프런css",
        "excerpt":"CSS란 정의-Cascading Style Sheets:HTML 웹문서의 스타일을 표현하는 언어로 html코드로 작성된 웹 요소들이 어떻게 표시되어야하는지 정의한다. 특징-선택자(selecter)와 속성, 속성값으로 이루어진다. body { font-size: 9px; } CSS 화면상 html로 이루어진 요소들에 대응해 스타일 세트를 각각 적용한다. {}중괄호로 이루어진 속성세트를 각 태그, 클래스, id에 적용할 수 있다. 적용된 속성세트들을 css파일로 저장해 html파일들에 import를...","categories": ["css"],
        "tags": ["css","frontend","inlearn"],
        "url": "/css/cssinflearn/",
        "teaser": null
      },{
        "title": "[jekyll & github] my_own_blog",
        "excerpt":"블로그를 만들기 위한 공부 공부한 내용들을 notion에 정리하다가 문득 이런 생각이 들었다. ‘공부하는 내용들을 어디에 정리하면 좋을까?’ ‘공부한 내용을 정리할거면 정리하는 과정도 공부가 되게 할 수는 없을까?’ 블로그를 만들겠다는 결심을 한 것은 이 생각으로부터 비롯되었다. 하지만 일반적인 네이버블로그, tistory는 내 성에 차지 않았다. 공부하고있는 내용들을 바로바로 적용하면서 적용할 수 있지...","categories": ["blog"],
        "tags": ["blog","jekyll","github","git"],
        "url": "/blog/blog-first/",
        "teaser": null
      },{
        "title": "[Frontend] css기초",
        "excerpt":"이 글은 개인적인 공부를 목적을 위한 글이며, 모든 내용은 생활코딩님의 html수업에서 학습한 내용을 적은 것입니다. CSS css 등장 이전의 상황 html에 더욱 심미적 요소를 가미하기위한 언어. 사람들은 html자체에 심미적 요소를 추가하기 위해 디자인 태그를 넣었지만 곧 한계를 느끼고 css라는 언어를 새로이 만들게 된다. &lt;!-- &lt;font&gt;라는 태그가 이에 관한 태그이다. --&gt;...","categories": ["css"],
        "tags": ["css","frontend","생활코딩"],
        "url": "/css/css/",
        "teaser": null
      },{
        "title": "[Frontend] html기초",
        "excerpt":"이 글은 개인적인 공부를 목적을 위한 글이며, 모든 내용은 생활코딩님의 html수업에서 학습한 내용을 적은 것입니다. HTML 코딩과 HTML applitcation, app, program, webpage, website 이것들은 바라보는 관점에 따라 이름만 달라진다. code, source, language로 만든 결과물을 의미한다. html은 이 중에서 가장 쉬우면서 중요하다. HTML 코딩 실습 환경 준비 웹브라우저와 에디터가 필요하다. window→메모장...","categories": ["html"],
        "tags": ["html","frontend","생활코딩"],
        "url": "/html/html/",
        "teaser": null
      },{
        "title": "[jekyll & github] layout에 대한 개념",
        "excerpt":"layout 테마에 포함된 모든 레이아웃, 모양, 컨텐츠 유형을 찾을 수 있다. default layout 다른 모든 레이아웃에서 상속된다. 이 레이아웃에는 - &lt;head&gt; elements - masthead navigation links - content - page footer - scripts 이 작성된다. 지킬의 블로그 페이지는 어떻게 구성되어있을까? index.html의 layout은 home.html이고, home.html의 레이아웃은 archive이다. archive.html의 레이아웃은 default이다. 우리는 가장...","categories": ["blog"],
        "tags": ["blog","jekyll","github","git"],
        "url": "/blog/blog-third-layout/",
        "teaser": null
      },{
        "title": "[jekyll & github] 공식문서 공부",
        "excerpt":"구조 inimal-mistakes ├── _data # 테마 커스터마이징 위한 데이터파일들 | ├── navigation.yml # 메인 네비게이션 링크(우측상단) | └── ui-text.yml # 테마의 UI에서 쓰이는 문자 ├── _includes | | 스닙펫(재사용가능코드의미) | ├── analytics-providers # snippets for analytics (Google and custom) | ├── comments-providers # snippets for comments | ├── footer |...","categories": ["blog"],
        "tags": ["blog","jekyll","github","git"],
        "url": "/blog/blog-references/",
        "teaser": null
      },{
        "title": "[javascript] 기초",
        "excerpt":"javascript란 객체기반의 스크립트 언어. 웹 문서에서 사용자와 다양한 상호작용 위한 언어이다. 백엔드 프로그램인 node.js등을 통해 다양한 프로그래밍에 응용되고있다. javascript와 ecmascript는 동일한 말이라고 생각하면된다. ajax는 웹사이트 접속했을떄 새로운 데이터를 보여주는 효과를 의미한다. 원리 서버에서 작성한 html과 css를 유저가 이를 요청하게된다. 보내준 이 정보를 사용자의 웹 브라우저가 읽으면서 사용자에게 이 정보를 보여주게된다....","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/javascript-first/",
        "teaser": null
      },{
        "title": "[javascript] 연산자",
        "excerpt":"비교연산자 결과를 boolean(true/false) 으로 반환한다. == 값이 같다. != 값이 다르다. === 값이 같고, 데이터타입도 일치한다. &lt; &gt; &lt;= &gt;= 논리연산자 boolean을 연산할 수 있다. &amp;&amp; and와 같음 || or와 같음 ! not과 같음 연산자의 우선순위 괄호 → 증감 연산자 → 산술 연산자 → 비교 연산자 → 논리 연산자 →...","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/javascript-second/",
        "teaser": null
      },{
        "title": "[javascript] 조건문과 반복문",
        "excerpt":"조건문 조건의 참 거짓에 따라 원하는 코드를 실행한다. If 조건문 if , else의 키워드로 조건문을 구성한다. if condition{ 코드 }else if{ 코드 }else { 코드 } else if로 조건을 계속 추가할 수 있다. 또한 실행코드가 한줄이면 중괄호 생략이 가능하다. if condition console.log() Switch 문 swithch 와 case의 조합으로 조건문을 만든다....","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/javascript-if/",
        "teaser": null
      },{
        "title": "[jekyll & github] jekyll post에 대해",
        "excerpt":"페이지에 포스트 목록을 생성하는 방법 지킬이 페이지에서 포스트 목록을 생성하는 방법 지킬의 포스트목록 표시 방법 소개 {% for post in site.posts %} &lt;li&gt; &lt;a href=\"{{ post.url }}\"&gt;{{ post.title }}&lt;/a&gt; &lt;/li&gt; `% endfor %} 여기선 이런 코드를 소개하고있는데 어떤 역할을 하는지 내 블로그를 토대로 공부해보자. _pages _pages의 내 카테고리들 하단에는 {%...","categories": ["blog"],
        "tags": ["blog","jekyll","github","git","liquid"],
        "url": "/blog/blog-jekyll/",
        "teaser": null
      },{
        "title": "[javascript] 배열형, 객체",
        "excerpt":"배열형 배열형이란 인덱스 기반으로 값을 순서대로 삽입할 수 있는 특별한 객체형태. 파이썬의 리스트와 같은 개념이다. 인덱스는 위치를 의미하고 0부터 시작한다. var array=[0,10,20] array[0];-&gt;0 array[2];-&gt;20 배열형 값의 삽입과 제거 length: 배열의 '크기'를 리턴(인덱스 0,1,2를 갖는다면 크기는3) push(): 배열에 맨 뒤에 새로운 값을 추가한다. ushift(): 배열에 맨 앞에 새로운 값을 추가한다. pop():...","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/javascript4/",
        "teaser": null
      },{
        "title": "[javascript] 함수,스코프",
        "excerpt":"함수 💡 fuction이란 함수란 독립적인 코드를 한데 묶어 놓은 것이다. 이렇게 코드를 한데 묶어 놓는 것을 함수의 정의(declaratione)이라고 한다. 이렇게 만들어진 함수는 호출을 통해 불러올 수 있고 재사용이 가능하다. 깔끔하게 만들어진 함수는 재사용성이 높고 유지보수가 편리하다. function 함수명(매개변수,parameter) { 실행코드 } 매개변수나 리턴값이 없을수도 있다. 💡 입출력 수학에서의 함수처럼 만들어진...","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/javascript-function/",
        "teaser": null
      },{
        "title": "[javascript] html코드에 javascript 가져오기",
        "excerpt":"자바스크립트의 작성방식 -인라인 스타일 html 태그에 이벤트 속성으로 직접 작성한다. -내부 스크립트:&lt;script&gt;&lt;/script&gt;에 작성 -❗️외부 스크립트: js파일에 작성 후 &lt;script&gt;태그로 import한다. 💡 외부 스크립트로 자바스크립트 파일 불러오기 &lt;body&gt; &lt;script type=\"text/javascript\" src=\"파일위치\"&gt;&lt;/script&gt; &lt;/body&gt; 💡 script태그를 상단에 쓰지 않는 이유 CSS파일은 html코드의 상단에서 작성해주었다. 하지만 JS파일은 상단에서 작성하지 않는다. html파일을 웹 브라우저가 읽고,...","categories": ["javascript"],
        "tags": ["javascript","js"],
        "url": "/javascript/htmljsconnect/",
        "teaser": null
      },{
        "title": "[Coding test][실버IV]BOJ #1056 한수(브루트포스 알고리즘)",
        "excerpt":"내 코드 import sys n = sys.stdin.readline().rstrip() cycle = 0 def d(n): global cycle a = list(map(int,str(n))) if a[0] - a[1] == a[1] - a[-1]: cycle += 1 for i in range(1,int(n)+1): if i &lt; 100: cycle += 1 else: d(i) print(cycle) 문제 정의 양의 정수 x의 각 자리가 등차수열을...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm"],
        "url": "/boj/boj-1056/",
        "teaser": null
      },{
        "title": "[Coding test][실버V]BOJ #4673 샐프넘버(수학, 구현)",
        "excerpt":"내 코드 import sys def d(n): num_list = list(map(int,str(n))) next_num= n + sum(num_list) return next_num lst = [] for num in range(1,10000): lst.append(d(num)) full_list = list(range(1,10000)) for i in full_list: if i not in lst: print(i) 문제 정의 주어진 수 n 과 주어진 수의 각 자리수를 더하는 함수가 있을때, n이라는...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm"],
        "url": "/boj/boj-4673/",
        "teaser": null
      },{
        "title": "[Coding test][실버V]BOJ #1316 그룹 단어 체커(문자열, 구현)",
        "excerpt":"내 풀이 import sys cycle = int(sys.stdin.readline().rstrip()) count = 0 for i in range(cycle): n = sys.stdin.readline().rstrip() checker = [] for char in n: if char in checker: if checker[-1] != char: break else: checker.append(char) else: count += 1 print(count) 문제 정의 연속된 문자가 문자열 내에 존재하고, 문자열 내에서 중복되지...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm"],
        "url": "/boj/boj-1316/",
        "teaser": null
      },{
        "title": "[Coding test][실버V]BOJ #2941 크로아티아 알파벳(문자열, 구현)",
        "excerpt":"내 코드 import sys n = sys.stdin.readline().rstrip() cro = [\"c=\", \"c-\", \"dz=\", \"d-\", \"lj\", \"nj\", \"s=\", \"z=\"] for i in range(len(cro)): n = n.replace(cro[i], \"*\") for i in range(len(n)): n = n.replace(\"=\", \"\") n = n.replace(\"-\", \"\") print(len(n)) 문제 정의 입력한 문자열에서 크로아티아 알파벳의 개수 + 크로아티아알파벳이 아닌 알파벳의 개수...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm"],
        "url": "/boj/boj-2941/",
        "teaser": null
      },{
        "title": "[Datastructure] 자료구조와 알고리즘",
        "excerpt":"자료구조와 알고리즘 자료: data 구조: 저장공간(memory) + 연산(읽기,쓰기,삽입,삭제,탐색) 알고리즘: 입력된 data를 기준으로 유한한 횟수의 연산을 반복해서 정답을 출력하는 것 자료구조 자료구조의 예시 1. 변수(variable) ``` a = 3 (쓰기연산) print(a) (읽기연산) ``` 3이 a에 담기는 것이 아닌, 3이 들어있는 &lt;u&gt;객체의 주소&lt;/u&gt;가 a에 담기는 것이다. ### 2. 배열(array) ``` a =...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python"],
        "url": "/datastructurepy/intro/",
        "teaser": null
      },{
        "title": "[Datastructure] 알고리즘의 시간복잡도",
        "excerpt":"자료구조와 알고리즘의 성능 자료구조와 알고리즘을 설계 → 코드 → 컴퓨터에서 실행 문제점 1. Hw/Sw에 따라 다른 성능 문제점 2. 다양한 크기의 입력 따라서 소프트웨어와 하드웨어환경과 독립적인 1가상컴퓨터(virtual machine)에 알고리즘을 기술할 2가상언어(pseudo language)로 3가상코드(psuedo code)를 작성한다. 우리가 이 3가지를 약속하면 하드웨어와 소프트웨어 환경에 독립적인 상황에서 객관적으로 알고리즘을 비교할 수 있다. 가상컴퓨터...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","time complexity"],
        "url": "/datastructurepy/timecomplexity/",
        "teaser": null
      },{
        "title": "[Datastructure] Big-O",
        "excerpt":"💡 Big-O표기법 ✏️ 의미 입력의 크기 n이 커질 때, 수행시간이 증가하는 정도, 즉 n의 차수가 가장 중요하다. n에 의한 영향을 가장 많이 받는, n의 최고차항의 계수를 삭제한 형태로 표현 ✏️ 방법 n에 대한 최고차항만을 남기고 다른 항은 삭제. n의 최고차항의 계수도 삭제한다. 남은 항을 O()에 넣는다. n의 차수가 크면 클수록...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","time complexity"],
        "url": "/datastructurepy/timecomplexity2/",
        "teaser": null
      },{
        "title": "[Datastructure] 배열, 리스트",
        "excerpt":"배열형태의 자료구조 의미 연속적인 메모리 공간에 저장된 곳의 주소에 접근하는 자료구조. c언어에서 배열형태 특징 배열의 시작주소 자료형태 찾고자 하는 자료의 인덱스 이 세가지 정보만 알 수 있다면 저장된 곳의 주소를 계산할 수 있다. a = [2,4,6,8] a[2]의 주소를 찾고자 한다면, a[0]의 시작 주소 + 자료형태에 따른 byte * 인덱스번호 로...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","time complexity"],
        "url": "/datastructurepy/array/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 리스트 표현식",
        "excerpt":"리스트 표현식 표현 방법 2가지 방식이 있다. [식 for 변수 in 리스트] list(식 for 변수 in 리스트) &gt;&gt;&gt; a = [i for i in range(10)] &gt;&gt;&gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; b = list(i for i in range(10)) &gt;&gt;&gt; b [0, 1, 2,...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","list-comprehension"],
        "url": "/pythonsyntax/listcomprehension/",
        "teaser": null
      },{
        "title": "[Coding test][실버II]BOJ #1929 소수 구하기(수학, 정수론, 소수판정, 에라토스테네스의 체)",
        "excerpt":"첫 번째 시도는 에라토스테네스의 체가 뭔지 모르고, 두 번째 시도는 알고도 틀렸다.😭 (문송…) 내 풀이 import sys m, n = map(int, sys.stdin.readline().split()) #일반적인 소수검증하기. def isprime(a): if a == 1: return False #1인경우, 소수판정 제외한다. else: #2부터 입력 a의 제곱근까지의 수들 중에서 2부터 i에 할당한다. for i in range(2, int(a**(1/2))...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm","소수판정"],
        "url": "/boj/boj-1929/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 문자열",
        "excerpt":"문자열 문자열은 튜플과 같이 직접적인 변환이 불가능하다. 문자열 바꾸기 따라서 문자열을 바꾸기 위해서는 a = 'hello world' b = a.replace(\"world\", \"python\") 과같이 다른 변수에 변경되는 결과를 할당해줘야한다. 문자 치환하기 str.maketrans(‘바꿀문자’,’새문자’)로 변환 테이블을 만들어 해당하는 문자들을 한 번에 바꿀수도 있다. table = str.maketrans('aeiou','12345') 'apple'.translate(table) &gt;&gt;&gt;\"1ppl2\" 서식 지정자 서식지정자는 %이다. 뒤에 자료형을...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","list-comprehension"],
        "url": "/pythonsyntax/string/",
        "teaser": null
      },{
        "title": "[Datastructure] 스택과 활용(1)",
        "excerpt":"스택 💡 스택이란 데이터 값을 저장하는 구조로 일차원의 선형 자료구조이다. 리스트가 가로형태로 배열되어있다면, 스택은 세로로 배열되어 있다. 허접한 그림이다. 봐주도록하자. 💡 사용법 list와 마찬가지로 삽입, 삭제, 탐색 연산이 제공된다. 단, 모든 연산은 LIFO원칙을 따라야한다. 💡 예시 push, pop, top, isEmpty, size(len) 의 5가지 연산이 제공된다고 가정하자. class stack: def __init__(self):...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","stack","스택"],
        "url": "/datastructurepy/stack/",
        "teaser": null
      },{
        "title": "[Datastructure] 스택과 활용(2) Infix to Postfix and calculation",
        "excerpt":"Infix, postfix 💡 의미 Infix 수식은 일반적인 수식 작성법이다. 연산자가 수식 가운데에 존재하는 수식 Postfix 수식은 수식 내의 연산자가 뒤에 오도록 작성한다. 💡 사용법 연산자 우선순위에 따라 괄호를 삽입한다. 괄호 내의 연산자를 해당 괄호 오른쪽으로 이동시키는 것을 반복한다. 괄호를 모두 지운다. prefix는 이동방향만 다르다. Infix►Postfix►Calculation 함수 만들기 💡 문제 정의...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","stack","스택","infix"],
        "url": "/datastructurepy/stack-cal/",
        "teaser": null
      },{
        "title": "[Algorithm] 메모이제이션(memoization)",
        "excerpt":"메모이제이션 메모이제이션이란 동적프로그래밍(Dynamic Programming)은 중복되는 문제가 있을 때, 재귀 관계를 상향식으로 해결한다. 메모이제이션은 최적화 문제를 풀 때, Caching 방식을 이용해 중복계산을 방지하고, 획기적으로 계산 시간을 줄인다. 이미 계산된 값을 테이블에 저장해 중복되는 계산이 발생할 경우, 불러온다. 메모이제이션은 해시테이블 또는 딕셔너리와 함께 쓸 때 강력한 위력을 발휘한다. 피보나치 수열에 적용 시간복잡도...","categories": ["algorithm"],
        "tags": ["computer science","algorithm","memoization"],
        "url": "/algorithm/memoization/",
        "teaser": null
      },{
        "title": "[Coding test][브론즈II]BOJ #2775 부녀회장이 될테야(수학)",
        "excerpt":"내 풀이 def apart(a,b): #a층b호 if a == 0: return b if b == 1: return 1 if lst[a][b-1] == -1: #만약 a층 b호가 계산이 안되어있다면, lst[a][b-1] = apart(a,b-1) + apart(a-1,b) return lst[a][b-1] lst = [[-1 for i in range(15)]for j in range(15)] # n,k가 14층,14호까지 있으므로, 초기값을 14*14 2차원...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm","메모이제이션","memoization"],
        "url": "/boj/boj-2775/",
        "teaser": null
      },{
        "title": "[Coding test][실버I]BOJ #9020 골드바흐의 추측(수학, 정수론, 소수 판정, 에라토스테네스의 체)",
        "excerpt":"내 풀이 def prime_list(a): sieve = [True] * (a+1) checkrange = int((a+1)**0.5) for i in range(2,checkrange+1): if sieve[i] == True: for j in range(i+i,a+1,i): sieve[j] = False sieve[0] = False sieve[1] = False return sieve lst_sieve = prime_list(10000) import sys t = int(sys.stdin.readline().rstrip()) for i in range(t): n = int(sys.stdin.readline().rstrip())...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm","소수판정","에라토스테네스의 체"],
        "url": "/boj/boj-9020/",
        "teaser": null
      },{
        "title": "[javascript] AJAX",
        "excerpt":"AJAX Asynchronous Javascript And Xml 자바스크립트에 내장된 xmlhttprequest 객체를 이용해서 페이지를 새로고침하지 않고도 필요한 데이터를 비동기적으로 불러오는 기법을 의미한다. 데이터양을 줄이기위해 html그 자체를 불러오는게 아니라, XML형식으로 백엔드의 데이터를 불러오는데 현재는 JSON 형식을 사용한다. 💡 AJAX 작동과정 화면에 렌더링이 끝난 시점이다. 사용자가 화면에서 어떤 버튼을 눌러 데이터를 추가요청한다. (이벤트 발생) 이때,...","categories": ["javascript"],
        "tags": ["javascript","js","json","ajax"],
        "url": "/javascript/ajax/",
        "teaser": null
      },{
        "title": "[javascript] 클로져의 개념",
        "excerpt":"Closure 함수는 선언되는 시점과 실행되는 시점이 서로 다르다. 선언하는 시점에 어떤 변수가 있는데, 프로그램이 실행되면서 그 변수는 바뀌게된다. 💡 클로저란 내부함수가 실행시점을 포함해 외부함수의 맥락에 접근할 수 있는 것. 쉽게 말해 함수가 정의된 시점에서 외부 변수들의 현재상태와 함수가 실행된 시점에서 외부 변수들의 상태를 격리한다. 선언시점에서의 변수값을 사용하고 싶다면 클로저는 외부...","categories": ["javascript"],
        "tags": ["javascript","js","closure"],
        "url": "/javascript/closure/",
        "teaser": null
      },{
        "title": "Boxsize",
        "excerpt":" ","categories": [],
        "tags": [],
        "url": "/boxsize/",
        "teaser": null
      },{
        "title": "[Hash] 해쉬함수에 대해",
        "excerpt":"해시함수 해시함수란 임의의 길이의 입력을 받아 고정된 길이의 출력을 하게끔 하는 함수이다. 우리가 만약 메이플 스토리 (참고로 난 안한다. 유서깊은 게임이라 예시로 든다.)를 하기위해 X슨에 가입해야된다고 하자. 우리가 입력해야하는 것은 아이디, 이메일 등과 비밀번호, 개인정보 등 이다. 이 입력받은 데이터를 회사 DB에 고대로 저장하면 회사 직원들도 이걸 볼 수 있고,...","categories": ["etc"],
        "tags": ["HASH","해시함수"],
        "url": "/etc/hash/",
        "teaser": null
      },{
        "title": "[Datastructure] 큐, Queue",
        "excerpt":"큐 스택은 후입선출법(LIFO)방식을 따르는 자료구조이다. 반면에 큐는 선입선출법(FIFO)방식을 따르는 자료구조이다. 회계를 배우면 2가지의 재고자산 매출원가 계산방식을 알 수 있다.(평균법과 선입선출법) 그래서 조금은 익숙한 개념이다. 큐의 연산 종류 enqueue: 큐에 rear 부분에 삽입한다. dequeue: 큐의 front 부분의 값을 삭제하고 리턴한다. front: 큐의 front 부분의 값을 리턴한다. Function class Queue(): def __init__(self):...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","Queue"],
        "url": "/datastructurepy/queue/",
        "teaser": null
      },{
        "title": "[Datastructure] 한방향 연결리스트",
        "excerpt":"연결리스트란 연결리스트는 파이썬의 리스트와는 다르게 key값과 link값으로 이루어져있다. 리스트는 각 인덱스가 메모리가 할당되어 각 원소의 주소값을 가지게된다. 그래서 상수시간 O(1) 내에 연산이 가능하다. 하지만 연결리스트는 각 메모리가 원소의 주소(key값) + 다음값이 저장된 주소(link값) 이 저장되어 있다. key값과 link값이 함께 저장되어 있는 것을 Node라고 부른다. class Node: def __init__(self, key =...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","singly linked list"],
        "url": "/datastructurepy/list/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 클래스, 메서드",
        "excerpt":"클래스와 메서드의 관계 클래스는 내가 자료구조를 공부하면서 배운 스택, 큐, 연결리스트 등을 공부하면서 자연스럽게 접할 수 있었다. class stack: def __init__(self): #클래스의 객체생성함수. self.items = [] def push(self,val): #삽입 self.items.append(val) def pop(self): #마지막 값 삭제, 리턴 try: return self.items.pop() except: print(\"stack is empty now\") def top(self) #마지막 값 리턴 try:...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","class","method"],
        "url": "/pythonsyntax/classmethod/",
        "teaser": null
      },{
        "title": "[Datastructure] 양방향 연결리스트",
        "excerpt":"양방향 연결 리스트란 한방향 연결 리스트의 단점을 보완한다. 한방향 연결 리스트의 경우, popback과 같은 리스트의 끝의 값을 찾는 연산으로 인해 시간복잡도가 O(N)이다. 양방향 연결리스트는 각 노드가 next node와 prev의 노드정보를 담는다. 따라서 한방향 연결리스트에 비해 시간복잡도가 크게 줄어든다. head node와 tail node는 항상 None인 더미노드이다. 노드 key,next,prev의 세가지 정보를 기본적으로...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","doubly linked list"],
        "url": "/datastructurepy/doublylinkedlist/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 예외처리 기법",
        "excerpt":"예외처리 의도대로 프로그램이 작동하지 않으면 , 비정상적으로 발생한 오류로 인해 프로그램이 멈추게된다. 이때 여러가지 오류가 발생하게된다. 이를 의도적으로 무시하거나, 다른 함수에 던지거나(?)하는 기법을 예외처리라고한다. 오류의 종류 systaxerror : 문법오류 print('a) print('a')) if True; typeerror : 다른 자료형끼리 연산하거나, 알맞지않은 자료형을 메서드에 쓸때 a = [1,2,3] print(a['1']) nameerror : 참조 불가능한...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","except","exception"],
        "url": "/pythonsyntax/exception/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 모듈, 패키지",
        "excerpt":"모듈 관련이 있는, 변수 클래스 함수등 파이썬 구성요소를 모아놓은 파일이다. 작성 중인 파일에서 다른 파일의 어떠한 변수, 클래스, 함수들을 가져올 수 있다. sys, math, random 등의 모듈들은 빌트인 모듈로 파이썬에서 기본적으로 제공하는 모듈들이다. 그래서 print(sys.path)를 해보면 파이썬이 모듈을 불러오는 경로가 문자열형태로 리스트화되어있는 것을 볼 수 있다. 이런 모듈의 경로를 따라...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","module","package"],
        "url": "/pythonsyntax/modulepackage/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 클래스 상속",
        "excerpt":"클래스 상속 클래스 상속이란 파생클래스가 기반클래스의 기능을 상속한다는 의미이다. 클래스 상속을 사용하면 클래스간 중복되는 코드를 작성하지 않아도 되어 코드의 재사용성이 높다. 기반클래스 = 부모클래스 = 슈퍼클래스 파생클래스 = 자식클래스 = 서브클래스 class superclass: def supergreeting(self): print('hello im superclass') class subclass(superclass): #파생클래스가 기반클래스를 상속 def subgreeting(self): print('im subclass') sub = subclass()...","categories": ["pythonsyntax"],
        "tags": ["python","syntax","class","inheritance"],
        "url": "/pythonsyntax/inheritance/",
        "teaser": null
      },{
        "title": "[jekyll & github] Collection의 grid로 Mylog 탭 만들기",
        "excerpt":"참고Minimal Mistakes 공식 사이트 네비게이션 바에 about을 지우고, 그 자리에 내 개인적인 일상글들을 올리는 공간을 만들고싶다. 네비게이션 바 My Logs를 누르면 화면에 보여질 블로그 글 -출처(Minimal Mistakes의 sample collections) 공식문서 공식문서에서 collection layout을 사용해 grid 형식의 템플릿을 사용하는 방법에 대해 잘 나와있다. Working with Collections-mmistakes 1._config.yml 수정 collections: mylogs: output:...","categories": ["blog"],
        "tags": ["blog","jekyll","github","git","liquid"],
        "url": "/blog/blog-collection/",
        "teaser": null
      },{
        "title": "[Datastructure] 해시테이블",
        "excerpt":"💡 해시테이블 소개 해시테이블: 매우 빠른 연산을 지원한다. 해시 테이블은 실용성이 뛰어나 광범위한 분야에서 사용된다. 일반 딕셔너리의 문제는 삽입,삭제,탐색이 자료안의 모든 정보를 탐색해야하기 때문에 시간복잡도가 O(N)이라는 것이다. 이를 개선하는 방법으로 해시테이블이 사용된다. 해시테이블을 사용하는 간단한 방법에 대해 알아보자. ✏️ 예시 key:value 형태로 item 62:\"새\"가 주어진다. funtion(%10)으로 연산한 값 2번 인덱스에...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","hashtable"],
        "url": "/datastructurepy/hashtable/",
        "teaser": null
      },{
        "title": "[React Native 자습서] ",
        "excerpt":"출처 리액트 공식문서 개요 리액트란 사용자 UI를 구축하기위한 효율적이고 유연한 Javascript 라이브러리이다. 특히, component라는 코드의 파편을 이용해 복잡한 UI구성을 돕는다. 리액트 컴포넌트 class ShoppingList extends React.Component { render() { return ( &lt;div className=\"shopping-list\"&gt; &lt;h1&gt;Shopping List for {this.props.name}&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); } } 위 코드는 JSX방식으로 작성되었는데,...","categories": ["React"],
        "tags": ["React Native","tutorial"],
        "url": "/react/tutorial/",
        "teaser": null
      },{
        "title": "[React Native][생활코딩]리액트 설치 ~ 배포",
        "excerpt":"설치 npm 다운로드 이후 npm install -g create-react-app 이렇게 전역공간에 npm을 설치한다. 터미널에서 설치하고자하는 폴더로 들어가서 (cd 파일명) npm create-react-app 실행 새로운 폴더에서 npm create-react-app 안되는 경우 새로운 폴더에서 안되는 경우도 있다. 이때는 전역공간에 create-react-app이 만들어지지 않았기때문이다. $ npm config set prefix /usr/local $ sudo npm install -g create-react-app $...","categories": ["Reactegoing"],
        "tags": ["React Native","생활코딩"],
        "url": "/reactegoing/reactstart/",
        "teaser": null
      },{
        "title": "[React Native][생활코딩]컴포넌트 ~ State와 props",
        "excerpt":"리액트가 없다면 public이라는 디렉토리는 npm run start 할때 파일을 찾는 곳이다. 만약, 리액트가 없다면 index.html a태그로 연결된 모든 페이지를 각각 만들어하므로 html의 구조를 한눈에 보기가 어렵지만, 리액트는 필요한 기능을 가진 컴포넌트를 만들고, 그것을 논리적으로 삽입하고, 삭제하는 등의 과정을 거치기때문에 유지보수,개발에 훨씬 용이하다. 리액트는 html파일에 직접적으로 태그를 작성하는게 아닌, 태그를 넣는...","categories": ["Reactegoing"],
        "tags": ["React Native","생활코딩"],
        "url": "/reactegoing/react2/",
        "teaser": null
      },{
        "title": "[React Native][생활코딩]이벤트 state props ~ 컴포넌트 이벤트 만들기",
        "excerpt":"state,props,render 어플리케이션을 역동적으로 만들어주는 이벤트 props, state, event가 서로 상호작용하면서 어플리케이션을 역동적으로 만들어준다. Content 컴포넌트가 현재 웹페이지가 어느 사이트인지에 따라 웹페이지의 새로고침 없이 화면이 그려지도록 할 수 있다. 💡state 수정 링크를 클릭하면 해당 동작에 따라 웹페이지가 변경되게해야한다. 리액트에서 현재 페이지가 어느 페이지인지 알려주는 요소로 mode라는 state를 생성한다. mode의 state를 welcome과...","categories": ["Reactegoing"],
        "tags": ["React Native","생활코딩"],
        "url": "/reactegoing/reactegoing/",
        "teaser": null
      },{
        "title": "[React Native][생활코딩] CRUD",
        "excerpt":"CRUD 소개 모든 정보기술은 기본적으로 create, read, update, delete의 기능을 가진다. sql에서도 쿼리에 대해 처음 배울때, CRUD로 입문했었다. 컴포넌트 구성 CRUD에 해당하는 각 버튼을 페이지의 컴포넌트로 만들자. read는 현재 mode:read에서 구현되어있다. delete의 경우, 링크를 클릭하는 것이 아닌 button으로 구현한다. import React, { Component } from 'react'; class Control extends Component...","categories": ["Reactegoing"],
        "tags": ["React Native","생활코딩"],
        "url": "/reactegoing/reactegoingcrud/",
        "teaser": null
      },{
        "title": "[Coding test][골드V]BOJ #5430 (큐, 덱)",
        "excerpt":"내 풀이 import sys from collections import Counter, deque test = int(sys.stdin.readline().rstrip()) for _ in range(test): #명령문 입력 command = sys.stdin.readline().rstrip() #명령문 속 문자열 개수 count = Counter(command) Rcount = count['R'] Dcount = count['D'] #데이터 개수 입력 n = int(sys.stdin.readline().rstrip()) data = sys.stdin.readline().rstrip() Q = deque() if n == 0:...","categories": ["boj"],
        "tags": ["boj","python","baekjoon","algorithm","큐","덱"],
        "url": "/boj/boh-5430/",
        "teaser": null
      },{
        "title": "[React Native][생활코딩] Update",
        "excerpt":"Update 기능 자신이 수정하고싶은 데이터를 수정하는 기능 현재 렌더링하고 있는 컨텐츠에서, control 컴포넌트로 App 컴포넌트의 state가 mode:'update'로 바뀔 때, 렌더링 중인 컨텐츠를 가져와야한다. 함수구분 getReadContent() 읽어올 데이터를 구분한다. Toc 컴포넌트는 유저가 Toc에서 렌더링하는 각 컨텐츠를 클릭하면 해당 컨텐츠의 id를 selectedcontentid로 수정한다. 현재 state에 저장된 각 컨텐츠의 id값을 비교해가면서 같으면 해당...","categories": ["Reactegoing"],
        "tags": ["React Native","생활코딩"],
        "url": "/reactegoing/reactegoingupdate/",
        "teaser": null
      },{
        "title": "[Python 문법공부] 파일 사용하기",
        "excerpt":"파일 사용법 쓰기모드로 열기 file = open('hello.txt','w') file.write('Hello World!') file.close() open으로 file이라는 객체가 생성되며, 이 객체의 메서드로 write, close와 같은 메서드를 사용한다. 해당 이름을 가진 파일을 쓰기모드로 연다. 해당 py파일이 있는 폴더에 파일을 작성한다. 읽기모드로 열기 file = open('hello.txt', 'r') s = file.read() print(s) file.close() 읽기모드로 파일을 열게되면, file 객체의...","categories": ["pythonsyntax"],
        "tags": ["python","syntax"],
        "url": "/pythonsyntax/filewr/",
        "teaser": null
      },{
        "title": "[Datastructure] 트리구조, 힙",
        "excerpt":"참고 자료 😇 신찬수 교수님 자료구조 강의 💡 트리구조 연결리스트는 각 노드들이 한 줄로 연결된 선형적인 자료구조이다. 하지만 트리는 부모-자식 관계를 계측정으로 표현한 일반적인 자료구조라고 할 수 있다. 트리 구조 중에 자식 노드가 1개인 것을 트리구조의 특별한 경우라고 말할 수 있다. ✏️ 구조 출처권희정님 github ✏️ 용어 부모/자식 노드 :...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","tree","heap"],
        "url": "/datastructurepy/tree$heap/",
        "teaser": null
      },{
        "title": "[Datastructure] 이진트리",
        "excerpt":"참고 자료 😇 신찬수 교수님 자료구조 강의 이진트리 정의 이진트리는 트리인데, 각 노드의 자식노드가 2개 이하인 트리이다. 일반적으로 자식노드가 많으면 유용한데, 삽입,삭제연산이 복잡해지기때문에 이진트리를 가장 많이 사용한다. 이진트리를 표현하는 방법 중에 리스트 또는 배열에 저장하는 방법을 배웠는데, 이런 자료구조를 heap이라고 배웠다. 힙이라는 자료구조는 모양성질과 힙성질 모두 갖춰야하기때문에 makeheap이라는 함수를 구현했다....","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","binarytree"],
        "url": "/datastructurepy/binarytree/",
        "teaser": null
      },{
        "title": "[Datastructure] 균형이진탐색트리",
        "excerpt":"참고 자료 😇 신찬수 교수님 자료구조 강의 8iggy님 블로그 geeksforgeeks 균형이진탐색트리 균형이진탐색트리를 사용하는 이유 앞에서 이진탐색트리를 공부할때, 각 노드마다 left subtree의 키값들이 right subtree의 키값보다 작다는게 보장되었다. 이진탐색트리에서 대부분의 연산은 find_loc 함수를 이용하기때문에 O(h) 시간복잡도를 가진다. 따라서 탐색을 효율적으로 하기위해서는 트리의 높이 h를 최소화해야한다는 결론이 나온다. 트리의 높이를 최소화하기 위해서는...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","BST"],
        "url": "/datastructurepy/balancedBST/",
        "teaser": null
      },{
        "title": "[Datastructure] Red-black 트리",
        "excerpt":"참고 자료 😇 신찬수 교수님 자료구조 강의 geeksforgeeks Red-Black 트리 개요 search, insert, delete를 O(log n) 시간 내에 처리할 수 있다. AVL트리와 Red-Black트리에 비해 더 균형있지만, insert, delete과정에서 많은 rotation을 호출한다. 만약 insertion과 deletion이 많은 작업이라면, Red-Black트리를 적용하는 것이 더 선호된다. 만약 insertion과 deletion보다 search가 더 많이 호출되는 작업이면 AVL트리를...","categories": ["datastructurepy"],
        "tags": ["computer science","data structure","python","red-black-tree"],
        "url": "/datastructurepy/rb234tree/",
        "teaser": null
      }]
