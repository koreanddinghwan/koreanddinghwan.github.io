I"<h1 id="메모이제이션">메모이제이션</h1>

<h2 id="메모이제이션이란">메모이제이션이란</h2>

<p>동적프로그래밍(Dynamic Programming)은 중복되는 문제가 있을 때, 재귀 관계를 상향식으로 해결한다.<br />
메모이제이션은 최적화 문제를 풀 때, Caching 방식을 이용해 중복계산을 방지하고, 획기적으로 계산 시간을 줄인다.<br />
이미 계산된 값을 테이블에 저장해 중복되는 계산이 발생할 경우, 불러온다.<br />
메모이제이션은 해시테이블 또는 딕셔너리와 함께 쓸 때 강력한 위력을 발휘한다.</p>

<p><br /><br /></p>

<h1 id="피보나치-수열에-적용">피보나치 수열에 적용</h1>

<h2 id="시간복잡도-o2n">시간복잡도 O(2^n)</h2>
<p>피보나치수열 함수를 만든다고 가정해보자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#fibo(0) = 0, fibo(1) = 1 이다.
</span>    <span class="k">return</span> <span class="n">n</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p><br />
<br /></p>

<p>이를 트리형태로 나타내면,<br />
<img src="https://user-images.githubusercontent.com/76278794/137487576-54dce025-cd40-401b-9f06-5dd08c65e8d0.jpeg" width="400" /></p>

<p>재귀함수 형태로 시간복잡도는 O(2^n)이 되어 매우 비효율적이다.</p>

<h1 id="메모이제이션을-적용한-피보나치수열">메모이제이션을 적용한 피보나치수열</h1>
<p>피보나치 수열을 메모이제이션 적용하면<br />
계산값을 해시테이블(list)에 각각의 계산된 객체주소를 저장하면서 나아가는형태로 나타내면</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#fibo(0), fibo(1)의 값을 가진 길이 n의 리스트를 생성(caching)
</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#피보나치수열은 fibo(2)부터 n까지 계산한다.
</span>    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c1">#인덱스 기준 2개 앞의 값을 더한다.
</span></code></pre></div></div>
<p><br />
<br />
하지만 이렇게 테이블을 미리 만들어놓고 코드를 작성하게 될 경우,</p>

<p>함수를 호출할때마다 테이블을 다시 만들게된다.<br />
따라서, 재귀함수에서 메모제이션을 적용하고, 함수 밖에서 캐시를 만들면</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
  <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">fibo</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</code></pre></div></div>
<p>으로 한 번 호출된 함수는 바깥 테이블에 저장되어, 함수를 여러번 호출해도 테이블은 1번만 만들어지게된다.</p>

<p>메모이제이션을 활용한 백준문제로는 <a href="https://koreanddinghwan.github.io/lightbig/boj/boj-2775/">백준2775번</a>을 참고하자.</p>

<h1 id="참고자료">참고자료</h1>
<p><a href="https://www.youtube.com/watch?v=YNIasN6kT2M">주니온TV 아무거나연구소</a></p>
:ET